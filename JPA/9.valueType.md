

## Intro

 - JPA 데이터 타입
	 - 엔티티 타입
		 - @Entity 로 정의하는 객체
		 - 식별자를 통해 지속적인 추적 가능
	 - 값 타입
		 - int, Integer, String 같은 자바 기본 타입이나 객체
		 - 식별자가 없어서 추적 불가
		 - 분류
			 - 기본값 타입 (basic value type)
				 - 자바 기본 타입 (ex- int, double)
				 - 레퍼 클래스 (ex - Integer)
				 - String
			 - 임베디드 타입 (Embedded type 복합 값 타입)
				 - JPA 에서 사용자가 직접 정의한 값
			 - 컬렉션 값 타입 (Collection value type)
				 - 하나 이상의 값 타입을 저장할 때 사용
## 9.1 기본값 타입
- Member class에 int a, String b 가 선언되어 있는 경우
	- Member 엔티티는 id 라는 식별자 값을 가지고 생명주기도 있음
	- 값 타입인 a와 b는 식별자 값도 없고 Member 엔티티에 의존함
		- Member 엔티티 삭제하면 a, b도 삭제됨
	- 값 타입은 공유하면 안됨
		- ex) 다른 Member 엔티티의 a 나 b를 변경했을 때 현재 Member 엔티티의 a와 b가 같이 변경되면 안되므로 공유 금지
		- 자바에서 int, double 같은 기본 타입 (primitive type) 은 절대 공유되지 않음 (assign 해도 값을 복사해서 저장)
## 9.2 임베디드 타입 (복합 값 타입)
- 새로운 값 타입을 정의해서 사용하는 것
- ex)
	``` 
    @Entity
    public class Member {
	    @Id @GeneratedValue
	    private Long id;
	    private String name;
	    
	    @Embedded Period workPeriod; // 근무 기간
	    @Embedded Address homeAddress; // 집 주소
	}
	```
	``` 
	@Embeddable
	public class Period {
		@Temporal(TemporalType.DATE) java.util.Date startDate;
		@Temporal(TemporalType.DATE) java.util.Date endDate;

		public boolean isWork(Date date) {
			// .. 값 타입을 위한 메소드 정의
		}
	}
	``` 
	``` 
	@Embeddable
	public class Address {
		@Column(name="city) // 매핑할 컬럼 정의 가능
		private String city;
		private String street;
		private String zipcode;
		// ...
	}
	``` 
	- 이렇게 새로 정의한 값들은 재사용이 가능하고 응집도도 높음
- 필요한 Annotation
	- **@Embeddable**
		- 값 타입을 **정의하는 곳**에 표시
	- **@Embedded**
		- 값 타입을 **사용하는 곳**에 표시
- 참고 : 하이버네이트는 임베디드 타입을 컴포넌트라고 부름
### 9.2.1 임베디드 타입과 테이블 매핑
![임베디드 타입 매핑](https://github.com/tatarobo/JPA/blob/master/JPA/image/pic1.png)
- 장점
	- 객체와 테이블을 아주 세밀하게 매핑 가능
		- 잘 설계한 ORM app은 매핑한 테이블의 수보다 클래스의 수가 많다
	- ORM 기능을 사용하지 않으면 보통 테이블 : 객체 = 1 : 1
### 9.2.2 임베디드 타입과 연과관계
- 임베디드 타입은 값 타입을 포함하거나 엔티티 참조 가능
![임베디드 타입과 연관관계](https://github.com/tatarobo/JPA/blob/master/JPA/image/pic2.png)
    ``` 
	@Entity
	public class Member {
	    @Embedded Address address;
	    @Embedded PhoneNumber phoneNumber;
	}
	
	@Embeddable
	public class Address {
		@Column(name="city) // 매핑할 컬럼 정의 가능
		private String city;
		private String street;
		@Embedded Zipcode zipcode;
	}
	
	@Embeddable
	public class Zipcode {
		private String zip;
		private String plusFour;
	}
	
	@Embeddable
	public class PhoneNumber {
		private String areaCode;
		private String localNumber;
		@ManyToOne PhoneServiceProvider provider;
	}
	
	@Entity
	public class PhoneServiceProvider {
		@Id String name;
	}
	``` 
### 9.2.3 @AttributeOverride: 속정 재정의
- 임베디드 타입에 정의한 매핑정보 재정의 시 사용
	``` 
	@Entity
	public class Member {
	    @Embedded Address homeAddress;
	    
	    @Embedded
	    @AttributeOverrides({
		    @AttributeOverride(name="city", column=@Column(name="COMPANY_CITY")),
		    @AttributeOverride(name="street", column=@Column(name="COMPANY_STREET")),
		    @AttributeOverride(name="zipcode", column=@Column(name="COMPANY_ZIPCODE"))
	    })
	    Address companyAddress;
	}
	``` 
- 이러면 실제 DB 상에 city, street, zipcode 뿐만 아니라 COMPANY_CITY, COMPANY_STREET, COMPANY_ZIPCODE 컬럼까지 추가됨
- **@AttributeOverrides 는 엔티티에 설정해야 한다**
	- *임베디드 타입이 임베디드 타입을 가지고 있어도 엔티티에 설정해야 한다*
### 9.2.4 임베디드 타입과 null
- 임베디드 타입이 null 이면 매핑한 컬럼 값 모두 null이 됨
## 9.3 값 타입과 불변 객체
@
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQwMjc2NzgzNywtMjA2ODU0MjI4OSw4Nj
gxNTM2NjksLTk4NzUxNzc2OSw3MzA5OTgxMTZdfQ==
-->