# 7. 고급 매핑 개요

* 상속관계 맵핑
	* 객체의 상속 관계를 DB에서 어떻게 매핑할지?
* @MappedSuperclass
	* 등록일, 수정일 등 여러 Entity에서 공통으로 사용하는 매핑 정보만 상속받기
* 복합 키와 식별관계 맵핑
	* DB 식별자가 하나 이상일 때
	* 식별관계 - 비식별관계
* 조인 테이블
	* 연관관계를 외래키로 관리하는 방법
	* 연관관계를 관리하는 연결 테이블을 두는 방법
* 엔티니 하나에 여러 테이블 맵핑하기
	* 말 그대로...

# 7.1 상속관계 맵핑

* RDB에는 상속 개념 없음.
* SuperType SubType Relationship 모델링 기법
	* 객체의 상속 개념과 가장 유사하다.
* 객체 상속 구조와 DB의 STSTR 관계를 맵핑
```
      물품
       |
 |-----|-----|
 |     |     |
음반   영화    책
```
### 논리 모델을 물리 모델인 테이블로 구현하는 3가지 방법
* 각각의 테이블로 변환
	* 각각을 모두 테이블로 만들고 조회할 때 Join을 사용
	* `Join 전략`
* 통합 테이블로 변환
	* 테이블을 하나만 사용해서 통합
	* `단일 테이블 전략`
* 서브타입 테이블로 변환
	* 각각의 서브타입마다 하나의 테이블을 생성
	* `테이블 전략`

### 7.1.1 Joined Strategy
```
                     ------------
                     ITEM
                     ------------
                     ITEM_ID (PK)
                     NAME
                     PRICE
                     DTYPE
                     ------------
                           |
       |-------------------|-------------------|
       |                   |                   |
--------------      --------------      --------------
ALBUM               MOVIE               BOOK
--------------      --------------      --------------
ITEM_ID(PK,FK)      ITEM_ID(PK,FK)      BOOK_ID(PK,FK)
ARTIST              DIRECTOR            AUTHOR
--------------      ACTOR               ISBN
                    --------------      --------------
```
* [Item](https://github.com/tatarobo/JPA/blob/master/programming/src/main/java/study/jpa/product/persistent/Item.java)
```java
@Entity
@Inheritance(strategy= InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
	@Id @GeneratedValue
	@Column(name = "ITEM_ID")
	private Long id;
}
```

* Album
```java
@Entity
@DiscriminatorValue("A")
public abstract class Album extends Item {
}
```

* Movie
```java
@Entity
@DiscriminatorValue("M")
public abstract class Movie extends Item {
}
```

* Book
```java
@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name = "BOOK_ID")
public abstract class Movie extends Item {
}
```

* 장점
	* 테이블 정규화
	* 외래키 참조 무결성 제약조건 가능
	* 저장공간 효율적 사용
* 단점
	* 조인 사용으로 인한 성능 저하
	* 조회 쿼리 복잡
	* 데이터 등록 시 insert SQL 두 번 실행

### 7.1.2 Single-Table Strategy
```
                     ------------
                     ITEM
                     ------------
                     ITEM_ID (PK)
                     NAME
                     PRICE
                     ARTIST
                     DIRECTOR
                     ACTOR
                     AUTHOR
                     ISBN
                     DTYPE
                     ------------
```

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
}
// 나머지 동일함.
```
* 장점
	* 조인 필요 없음 -> 조회 성능 빠르다.
	* 조회 쿼리가 단순.
* 단점
	* 자식 Entity가 mapping한 컬럼은 모두 null을 허용해야 함.
	* 단일 테이블에 모든 것을 저장 -> 테이블이 커짐 -> 상황에 따라 조회 성능이 오히려 느려짐.
* 특징
	* 구분 컬럼 반드시 사용 (@DiscriminatorColumn)
	* @DiscriminatorValue 미지정 시 Entity 이름을 기본값으로 사용함.
		* 예: `Movie, Album, Book`

### 7.1.3 Table-per-Concrete-Class Strategy
```
--------------      --------------      --------------
ALBUM               MOVIE               BOOK
--------------      --------------      --------------
ITEM_ID(PK)         ITEM_ID(PK)         BOOK_ID(PK)
NAME                NAME                NAME
PRICE               PRICE               PRICE
ARTIST              DIRECTOR            AUTHOR
--------------      ACTOR               ISBN
                    --------------      --------------
```

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item {
}
// 나머지 동일함. (@DiscriminatorValue 사용안함)
```
* 일반적으로 추천하지 않음. `(난 좋아보이는데...)`
* 장점
	* 서브 타입을 구분해서 처리할 때 효과적.
	* not null 제약조건 사용 가능
* 단점
	* 여러 자식 테이블을 함께 조회 시 성능 느림. (UNION Query)
	* 자식 테이블 통합 쿼리 못짬.
* 특징
	* 구분 컬럼 사용안함.

여기까지는 부모-자식 관계의 클래스를 DB 테이블에 맵핑함.

# 7.2 @MappedSuperclass

부모 클래스는 테이블과 맵핑하지 않고, 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공한다.

@MappedSuperclass = 추상클래스와 비슷, 실제 테이블과 맵핑되지 않음. 맵핑정보 상속을 목적으로 함.
@Entity = 실제 테이블에 맵핑됨.

[p.252 그림 7.7]

```java
@MappedSuperclass
public abstract class BaseEntity {
	@Id @GeneratedValue
	private Long id;
	private String name;
}

@Entity
public class Member extends BaseEntry {
	private String email;
}

@Entity
public class Seller extends BaseEntry {
	private String shopName;
}
```

* BaseEntity에 객체들이 주로 사용하는 공통 맵핑 정보를 정의한다.
	* id, 생성일자, 수정일자, 삭제일자 등등
* 매핑정보 재정의
	* @AttributeOverride
	```java
	@Entity
	@AttributeOverride(name="id", column=@Column(name="MEMBER_ID"))
	public class Member extends BaseEntity {...}
	```

	* @AttributeOverrides
	```java
	@Entity
	@AttributeOverrides({
		@AttributeOverride(name="id", column=@Column(name="MEMBER_ID")),
		@AttributeOverride(name="name", column=@Column(name="MEMBER_NAME"))
	})
	public class Member extends BaseEntity {...}
	```

	* @AssociationOverrides
	* @AssociationOverride
		* 설명이 없다!
* 정리
	* 테이블과 매핑하지 않음.
	* 자식 클래스에 Entity의 매핑 정보를 상속하기 위해 사용.
	* @MappedSuperclass로 지정한 클래스는 Entity가 아니다.
		* em.find(), JPQL 사용할 수 없다.
	* 이 클래스를 직접 생성해서 사용할 일은 거의 없다.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY0NDI4NTIxMSwxODcxMDkzNzEwLDc0MT
A0NjIwNiwtMTI0MzE2MDYzMiwtMTI3NTYxMDE1NSwtMTQ2MTEz
MjU3OCwtOTA4MTAzNzc3LDU2NTU0ODgxMF19
-->