


# 6. 실행 계획
## 6.1 개요
### 6.1.1 쿼리 실행 절차
* 첫 번째 단계 : SQL 파싱
	* SQL 파서 모듈이 담당
	* SQ 파스 트리 생성
* 두 번째 단계 : 최적화 및 실행 계획 수립
	* MySQL 서버의 옵티마이저가 담당
	* 실행 계획 생성
* 세 번째 단계 : 데이터를 읽어옴
	* 수립된 실행 계획을 바탕으로 스토리 엔진에 레코드를 읽어오도록 요청
	* MySQL 엔진에서 읽어온 레코드를 조인하거나 정렬하는 작업 수행 
### 6.1.2 옵티마이저의 종류
* 규칙 기반 최적화 방법
	* 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저에 내장된 우선 순위에 따라 실행 계획 수립
	* old한 방법
* 비용 기반 최적화 방법
	* 여러 가지 가능한 실행 계획중 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 토대로 최소 비용이 드는 실행 계획 선택.
### 6.1.3 통계 정보
* 비용 기반 최적화에서 가장 중요한 것은 통계 정보. 
	* 예) 잘못된 통계 정보에 의해 인덱스 레인지 스켄이 아니라 풀 테이블 스캔이 일어나 성능 저하를 일으킬 수 있음
* MySQL에서 관리되는 통계 정보 : 대략의 레코드 건수, 인덱스의 유니크한 값의 개수 정도
* 레코드 건수가 많지 않으면 통계 정보가 부정확한 경우 발생 -> ANALYZE 명령을 이용해 강제로 정보 갱신 필요 (인덱스 키값의 분포도만 업데이트)
	* MEMORY : 통계 정보X
	* MyISAM : 테이블과 인덱스 통계 정보 존재, 읽기O 쓰기X
	* InnoDB  : 테이블과 인덱스 통계 정보 존재, 읽기X 쓰기X
## 6.2 실행 계획 분석
EXPLAIN
* 쿼리의 실행 계획을 확인하는 명령어
```
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
LIMIT 10;
```
* 결과
	* 레코드는 쿼리 문장에서 사용된 테이블(임시 테이블도 포함)의 개수만큼 출력
	* 실행순서는 위에서 아래로 진행
	* 실행 계획 산출 위해 일부 직접 실행하기도 함
	* UPDATE, INSERT, DELETE문장에 대해서는 실행 계획 확인 불가

|id|select_type|table|type|Key|Key_len|ref|rows|Extra|
|--|----------|-----|----|---|-------|---|----|-----|
|1|SIMPLE|e|index|ix_firstname|44||300584|Using index|
|1|SIMPLE|s|ref|PRIMARY|4|employees.e.emp_no|4||

### 6.2.1 id 칼럼
* 단위 SELECT 쿼리별로 부여되는 식별자. p269-2
* 만약  하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다. p269-1
### 6.2.2 select_type 칼럼
* 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼.
* SIMPLE
* 
### 6.2.3 table 칼럼
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM2MDYxNDA3MiwtMTMxMzcwNTA1NCwtMT
A3NzU1NTAzMSwxOTk1Mzc3NzQ2LDE5NDg1NzUwNTQsLTE4Mzkz
NzY0MjBdfQ==
-->