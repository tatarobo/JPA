


# 6. 실행 계획
## 6.1 개요
### 6.1.1 쿼리 실행 절차
* 첫 번째 단계 : SQL 파싱
	* SQL 파서 모듈이 담당
	* SQ 파스 트리 생성
* 두 번째 단계 : 최적화 및 실행 계획 수립
	* MySQL 서버의 옵티마이저가 담당
	* 실행 계획 생성
* 세 번째 단계 : 데이터를 읽어옴
	* 수립된 실행 계획을 바탕으로 스토리 엔진에 레코드를 읽어오도록 요청
	* MySQL 엔진에서 읽어온 레코드를 조인하거나 정렬하는 작업 수행 
### 6.1.2 옵티마이저의 종류
* 규칙 기반 최적화 방법
	* 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저에 내장된 우선 순위에 따라 실행 계획 수립
	* old한 방법
* 비용 기반 최적화 방법
	* 여러 가지 가능한 실행 계획중 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 토대로 최소 비용이 드는 실행 계획 선택.
### 6.1.3 통계 정보
* 비용 기반 최적화에서 가장 중요한 것은 통계 정보. 
	* 예) 잘못된 통계 정보에 의해 인덱스 레인지 스켄이 아니라 풀 테이블 스캔이 일어나 성능 저하를 일으킬 수 있음
* MySQL에서 관리되는 통계 정보 : 대략의 레코드 건수, 인덱스의 유니크한 값의 개수 정도
* 레코드 건수가 많지 않으면 통계 정보가 부정확한 경우 발생 -> ANALYZE 명령을 이용해 강제로 정보 갱신 필요 (인덱스 키값의 분포도만 업데이트)
	* MEMORY : 통계 정보X
	* MyISAM : 테이블과 인덱스 통계 정보 존재, 읽기O 쓰기X
	* InnoDB  : 테이블과 인덱스 통계 정보 존재, 읽기X 쓰기X
## 6.2 실행 계획 분석
EXPLAIN
* 쿼리의 실행 계획을 확인하는 명령어
```
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
LIMIT 10;
```
* 결과
	* 레코드는 쿼리 문장에서 사용된 테이블(임시 테이블도 포함)의 개수만큼 출력
	* 실행 계획 산출 위해 일부 직접 실행하기도 함
	* UPDATE, INSERT, DELETE문장에 대해서는 실행 계획 확인 불가

|id|select_type|table|type|Key|Key_len|ref|rows|Extra|
|--|----------|-----|----|---|-------|---|----|-----|
|1|SIMPLE|e|index|ix_firstname|44||300584|Using index|
|1|SIMPLE|s|ref|PRIMARY|4|employees.e.emp_no|4||

### 6.2.1 id 칼럼
*단위 SELECT 쿼리별* 로 부여되는 식별자. p269-2
* 만약  하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다. p269-1
### 6.2.2 select_type 칼럼
*각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시* 되는 칼럼.
* **SIMPLE**
	* UNION이나 서브 쿼리를 사용하지 않은 단순한 SELECT 쿼리인 경우에 해당.
	* select_type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재. (일반적으로 바깥 쿼리가 그렇다.) p268-3
* **PRIMARY**
	* UNION이나 서브 쿼리가 포함된 SELECT 쿼리인 경우 가장 바깥쪽에 있는 단위 쿼리에 해당. p270-1
	* select_type이 PRIMARY인 단위 쿼리는 반드시 하나만 존재
* **UNION**
	* UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리인 경우에 해당. p270-1
* **DEPENDENT UNION**
	* select_type이 UNION과 마찬가지로 UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리인 경우에 해당. p271-1
	* UNION이나 UNION ALL로 결합된 단위 쿼리가 외부의 영향을 받는 경우.
	* DEPENDENT 키워드를 포함하는 서브 쿼리는 외부 쿼리에 의존적이기 때문에 절대 외부 쿼리보다 먼저 실행 될 수 없다. 대부분 비효율적인 경우가 많다.
* **UNION RESULT**
	* UNION 결과를 담아두는 테이블을 의미. p272-1
	* 실제 쿼리에서 단위 쿼리가 아니기 때문에 id 값은 부여되지 않는다.
* **SUBQUERY**
	* FROM 절 이외에서 사용되는 서브 쿼리를 의미. p273-1
* **DEPENDENT SUBQUERY**
	* 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우. p274-1
* **DERIVED**
	* FROM 절에 사용된 서브 쿼리를 의미
	* 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미.(파생 테이블)
	* MySQL은 FROM 절에 사용된 서브 쿼리를 제대로 최적화하지 못할 대가 대부분.
		* 파생 테이블에는 인덱스가 없어 다른 테이블과 조인할 때 성능상 불리
* **UNCACHABLE SUBQUERY**
	* 서브 쿼리에 포함된 요소에 의해 캐시가 불가능한 경우. p277-1
		* 사용자 변수가 서브 쿼리에 사용된 경우
		* NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에 사용된 경우
		* UUID() 나 RAND()와 같이 결과 값이 호출할 때마다 달라지는 함수가 사용된 경우.
* **UNCACHABLE UNION**
	* UNCACHABLE UNION 속성이 혼합된 타입 
### 6.2.3 table 칼럼
* 테이블의 이름에 별칭이 부여된 경우 별칭이 표시. 그렇지 않은 경우 NULL 표시.
* <>로 둘러싸인 이름이 명시되는 경우, 임시 테이블을 의미.
	* <>안에 표시되는 숫자는 단위 SELECT 쿼리의 id를 지칭.
 
|id|select_type|table|type|Key|Key_len|ref|rows|Extra|
|--|----------|-----|----|---|-------|---|----|-----|
|1|PRIMARY|<derived2>|ALL||||10420||
|1|PRIMARY|e|eq_ref|PRIMARY|4|de1.emp_no|1||
|2|DERIVED|dept_emp|range|ix_fromdate|3||20550||

* 해석
	* 첫 번째 라인의 테이블이 <derived2>로 보아 쿼리의 id가2번인 라인이 먼저 실행되고 그 결과 파생 테이블.
	* 세 번째 라인의 쿼리 id 2번을 보면 select_type이 DERIVED로 표시 되어 있음. 즉, dept_emp를 읽어서 파생 테이블을 생성.
	* 첫 번째 라인과 두 번째 라인이 같은 id값을 가지고 있는 것으로 봐서 2개 테이블(<derived2> 와 e)는 조인되는 쿼리.
	* <derived2>테이블이  e 테이블보다 먼저 표시 됐기 때문에 <derived2> 테이블을 먼저 읽어서 e 테이블로 조인을 실행.


```
EXPLAIN
SELECT *
FROM
	(SELECT de.emp_no FROM dept_emp de) tb, 
	employees e
WHERE e.emp_no=tb.emp_no;
```
### 6.2.4 type 칼럼
*MySQL 서버가 각 테이블의 레코드를 어떤 방식(인덱스를 사용한 접근 방식 또는 풀 스캔)으로 읽었는지를 의미.* 일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 TYPE 칼럼은 중요.

성능이 빠른 순서대로 나열.
* **system**
	* 레코드가 1건 또는 존재하지 않는 테이블을 참조하는 형태
		* InnoDB에서는 ALL 또는 index로 표시.
* **const (*)**
	* **프라이머리 키나 유니크 키에 대해 동등 조건으로 검색.  반드시 1건의 레코드 반환** p281-3
		* 프라이머리키가 다중 칼럼으로 구성 시 모든 칼럼이 포함되어야지만 해당 접근 방법 사용
		* 다른 DBMS에서는 UNIQUE INDEX SCAN이라고 표현
		* type이 const인 실행 계획은 옵티마이저가 쿼리를 최적화하는 단계에서 상수화 한다. p283-1
* **eq_ref (*)**
	* 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시. 조인에서 **두 번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색** 할 때 사용하는 접근 방법. **두 번째 테이블은 반드시 1건의 레코드만 반환**
* **ref (*)**
	* 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키등의 제약 조건도 없다. **WHERE 절에 동등 조건으로 검색**할 때 사용되는 방법.
* **fulltest**
* **ref_or_null**
* **unique_subquery**
* **index_subquery**
* **range**
* **index_merge**
* **index**
* **ALL**
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5Mjc1NzY2MzIsMTg3OTk5NDU1MywtMT
Q5MDI0ODc2NCwtMTcyNzU3NDQ0MSwxNTQwODgxODQxLDEwNzcw
MzYxMDgsLTEwNTkzODU0NCw4MjQ5ODUwOTcsMTI5NDA2MDM3Ny
wxNDkyNzUzNzA2LDE0NjAxOTc1MzIsNzI3MDIzOTY4LDE4NTc2
NzA0MTYsLTc3NzkzMDcyNyw2ODYyMzM0MDksMTA0NjQ4ODcwNi
wtMTMxMzcwNTA1NCwtMTA3NzU1NTAzMSwxOTk1Mzc3NzQ2LDE5
NDg1NzUwNTRdfQ==
-->