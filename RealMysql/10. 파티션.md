# 10. 파티션
* 파티션이란?
	* MySQL 서버의 입장에서 **데이터를 별도의 테이블로 분리해서 저장**하지만, 사용자 입장에서는 **여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는** 솔루션
	* 하나의 서버에서 테이블을 분산하는 것 (원격 서버 간 분산은 아님)
	* 대부분의 스토리지 엔진에서 사용 가능
	* 종류
		* 해시
		* 리스트
		* 키
		* 레인지
	* 서브 파티셔닝도 가능
## 10.1 개요
* 파티션이 SQL 문장 수행에 어떤 영향을 미치는지, 파티션으로 기대할 수 있는 장점은 무엇인지
### 10.1.1 파티션을 사용하는 이유
* 대표적인 경우
	* 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 큰 경우
	* 데이터 특성상 주기적인 삭제 작업이 필요한 경우
#### 단일 INSERT 와 단일 또는 범위 SELECT 의 빠른 처리
* 인덱스의 워킹 셋 (working set) 이 실질적인 물리 메모리보다 크다면 쿼리 처리가 상당히 느려짐
	* 테이블 데이터는 실질적인 물리 메모리보다 큰 것이 일반적
* 테이블을 파티셔닝하지 않고 그냥 사용할 때와 작은 파티션으로 나눠서 워킹 셋의 크기를 줄였을 때 인덱스의 워킹 셋이 물리적인 메모리를 어떻게 사용하는지
	![그림 10-1](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Photo_2021-05-24-23-11-36.jpeg)
	* 파티셔닝하지 않은 경우 : 인덱스도 커지고 그만큼 물리적인 메모리 공간도 많이 필요해짐
* 파티션의 효과
	* 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 함
> 참고
> * 테이블의 데이터가 10GB, 인덱스가 3GB라고 가정
> 	* 대부분의 테이블은 13GB 전체를 항상 사용하는 게 아니라 특히 활발하게 사용하는 부분을 다시 사용함
> * 활발하게 사용되는 데이터 = 워킹 셋
> * 테이블의 데이터를 워킹 셋과 그렇지 않은 부류로 파티셔닝 할 수 있다면 상당히 효과적으로 성능을 개선할 수 있음
#### 데이터의 물리적인 저장소를 분리
* 데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다 = 백업이나 관리 작업이 어려워짐
* 테이블의 데이터나 인덱스를 파일 단위로 관리하는 MySQL에서는 더 치명적
* 테이블의 파티션 단위로 인덱스를 순차적으로 생성하는 방법은 아직 허용되지 않음
#### 이력 데이터의 효율적인 관리
* 이력 데이터 = 로그
* 특징
	* 단기간에 대량으로 누적
	* 일정 기간이 지나면 쓸모가 없어짐
* 로그 테이블을 파티션을 사용해 기간 단위로 쪼개서 삭제하면 서버 부하와 테이블 동시성 문제를 해결할 수 있다
### 10.1.2 MySQL 파티션의 내부 처리

    CREATE TABLE tb_article (
     article_id INT NOT NULL,
     col1 VARCHAR(45) NULL,
     reg_date DATETIME NOT NULL,
     PRIMARY KEY (article_id)
    )
    PARTITION BY RANGE ( YEAR(reg_date) ) (
     PARTITION p2009 VALUES LESS THAN (2010),
     PARTITION p2010 VALUES LESS THAN (2011),
     PARTITION p2011 VALUES LESS THAN (2012),
     PARTITION p9999 VALUES LESS THAN MAXVALUE
    );

![또잉?!](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2010.53.14.png)
* 원인
	* 문서 : [링크](https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations-partitioning-keys-unique-keys.html)
	* 내용
		* In other words, _every unique key on the table must use every column in the table's partitioning expression_. (This also includes the table's primary key, since it is by definition a unique key. This particular case is discussed later in this section.)
	* 즉, reg_date 이 pk 에 포함되어 있지 않아서임
* 아래와 같이 create ddl 을 변경해 봄
```
CREATE TABLE tb_article (
 article_id INT NOT NULL,
 col1 VARCHAR(45) NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (article_id, reg_date)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
![성공](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.08.13.png)
* 그렇다면 unique key 가 있으면서 pk가 아닌 경우는 어떻게 될까
```
CREATE TABLE tb_article (
 article_id INT NOT NULL,
 col1 VARCHAR(45) NULL,
 col2 INT NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (article_id, reg_date),
 UNIQUE KEY (col2)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
![안된다..](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.11.42.png)

> ERROR 1503 (HY000): A UNIQUE INDEX must include all columns in the table's partitioning function
* 이런 에러가 뜨는 걸로 봐서 Unique Index 를 설정하려면 reg_date 도 unique 해야한다는 것을 알 수 있음
```
CREATE TABLE tb_article (
 article_id INT NOT NULL,
 col1 VARCHAR(45) NULL,
 col2 INT NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (article_id, reg_date),
 UNIQUE KEY (col2, reg_date)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
![성공](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.15.30.png)
> 참고 
> ` UNIQUE KEY (col2, reg_date) ` 이 부분을 ` UNIQUE KEY (col2), UNIQUE KEY (reg_date) ` 이렇게 바꿔도 된다. 그러나 이럴 경우 등록일 (reg_date) ㅇ

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTIzNDM4MTcyMCw0MTk1ODkzLC0xMDI2ND
E5OTc4LDE5MjcwMTE1NzUsLTEzNTc1NzgyMDQsLTE4MzY3Njg5
ODgsLTExMTMxMjc3OSwxNTA5NzY3NTk4XX0=
-->