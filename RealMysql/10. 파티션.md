# 10. 파티션
* 파티션이란?
	* MySQL 서버의 입장에서 **데이터를 별도의 테이블로 분리해서 저장**하지만, 사용자 입장에서는 **여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는** 솔루션
	* 하나의 서버에서 테이블을 분산하는 것 (원격 서버 간 분산은 아님)
	* 대부분의 스토리지 엔진에서 사용 가능
	* 종류
		* 해시
		* 리스트
		* 키
		* 레인지
	* 서브 파티셔닝도 가능
## 10.1 개요
* 파티션이 SQL 문장 수행에 어떤 영향을 미치는지, 파티션으로 기대할 수 있는 장점은 무엇인지
### 10.1.1 파티션을 사용하는 이유
* 대표적인 경우
	* 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 큰 경우
	* 데이터 특성상 주기적인 삭제 작업이 필요한 경우
#### 단일 INSERT 와 단일 또는 범위 SELECT 의 빠른 처리
* 인덱스의 워킹 셋 (working set) 이 실질적인 물리 메모리보다 크다면 쿼리 처리가 상당히 느려짐
	* 테이블 데이터는 실질적인 물리 메모리보다 큰 것이 일반적
* 테이블을 파티셔닝하지 않고 그냥 사용할 때와 작은 파티션으로 나눠서 워킹 셋의 크기를 줄였을 때 인덱스의 워킹 셋이 물리적인 메모리를 어떻게 사용하는지
	![그림 10-1](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Photo_2021-05-24-23-11-36.jpeg)
	* 파티셔닝하지 않은 경우 : 인덱스도 커지고 그만큼 물리적인 메모리 공간도 많이 필요해짐
* 파티션의 효과
	* 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 함
> 참고
> * 테이블의 데이터가 10GB, 인덱스가 3GB라고 가정
> 	* 대부분의 테이블은 13GB 전체를 항상 사용하는 게 아니라 특히 활발하게 사용하는 부분을 다시 사용함
> * 활발하게 사용되는 데이터 = 워킹 셋
> * 테이블의 데이터를 워킹 셋과 그렇지 않은 부류로 파티셔닝 할 수 있다면 상당히 효과적으로 성능을 개선할 수 있음
#### 데이터의 물리적인 저장소를 분리
* 데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다 = 백업이나 관리 작업이 어려워짐
* 테이블의 데이터나 인덱스를 파일 단위로 관리하는 MySQL에서는 더 치명적
* 테이블의 파티션 단위로 인덱스를 순차적으로 생성하는 방법은 아직 허용되지 않음
#### 이력 데이터의 효율적인 관리
* 이력 데이터 = 로그
* 특징
	* 단기간에 대량으로 누적
	* 일정 기간이 지나면 쓸모가 없어짐
* 로그 테이블을 파티션을 사용해 기간 단위로 쪼개서 삭제하면 서버 부하와 테이블 동시성 문제를 해결할 수 있다
### 10.1.2 MySQL 파티션의 내부 처리

    CREATE TABLE tb_article (
     article_id INT NOT NULL,
     col1 VARCHAR(45) NULL,
     reg_date DATETIME NOT NULL,
     PRIMARY KEY (article_id)
    )
    PARTITION BY RANGE ( YEAR(reg_date) ) (
     PARTITION p2009 VALUES LESS THAN (2010),
     PARTITION p2010 VALUES LESS THAN (2011),
     PARTITION p2011 VALUES LESS THAN (2012),
     PARTITION p9999 VALUES LESS THAN MAXVALUE
    );

![또잉?!](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2010.53.14.png)
* 원인
	* 문서 : [링크](https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations-partitioning-keys-unique-keys.html)
	* 내용
		* In other words, _every unique key on the table must use every column in the table's partitioning expression_. (This also includes the table's primary key, since it is by definition a unique key. This particular case is discussed later in this section.)
	* 즉, reg_date 이 pk 에 포함되어 있지 않아서임
* 아래와 같이 create ddl 을 변경해 봄
```
CREATE TABLE tb_article (
 article_id INT NOT NULL,
 col1 VARCHAR(45) NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (article_id, reg_date)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
![성공](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.08.13.png)
* 그렇다면 unique key 가 있으면서 pk가 아닌 경우는 어떻게 될까
```
CREATE TABLE tb_article (
 article_id INT NOT NULL,
 col1 VARCHAR(45) NULL,
 col2 INT NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (article_id, reg_date),
 UNIQUE KEY (col2)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
![안된다..](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.11.42.png)

> ERROR 1503 (HY000): A UNIQUE INDEX must include all columns in the table's partitioning function
* 이런 에러가 뜨는 걸로 봐서 Unique Index 를 설정하려면 reg_date 도 unique 해야한다는 것을 알 수 있음
```
CREATE TABLE tb_article (
 article_id INT NOT NULL,
 col1 VARCHAR(45) NULL,
 col2 INT NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (article_id, reg_date),
 UNIQUE KEY (col2, reg_date)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
![성공](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.15.30.png)
> 참고 
> ` UNIQUE KEY (col2, reg_date) ` 이 부분을 ` UNIQUE KEY (col2), UNIQUE KEY (reg_date) ` 이렇게 바꾸면 아래와 같이 위와 동일한 에러가 발생한다
> ERROR 1503 (HY000): A UNIQUE INDEX must include all columns in the table's partitioning function
> partition key 는 pk 를 등록하면 pk와 함께 묶여야 하고, unique key 를 등록하면 등록한 unique key 와도 함께 묶여야 하는 걸 잊지 말자
#### 파티션 테이블의 레코드 INSERT
* INSERT 쿼리가 실행된 후 동작
	1) INSERT 되는 컬럼의 값 중 파티션 키인 reg_date 칼럼의 값을 사용해 파티션 표현식을 평가함
	2) 평가 결과를 이용해 레코드가 저장될 적절한 파티션을 결정
	3) 새로 INSERT 되는 레코드의 파티션이 결정되면 나머지는 파티션되지 않은 일반 테이블 INSERT 와 마찬가지로 처리
#### 파티션 테이블의 UPDATE
* UPDATE 쿼리가 실행된 후 동작
	1) 변경 대사 레코드가 어느 파티션에 저장되어 있는지 찾음
	2) where 조건 절로 판단
		* **WHERE** 조건에 **파티션 키 칼럼**이 조건으로 ***존재하는*** 경우
			* 해당 키 값을 이용해서 레코드가 저장된 파티션에서 빠르게 대상 레코드 검색 가능
		* **WHERE** 조건에 **파티션 키 칼럼**이 조건으로 ***존재하지 않는*** 경우
			* 테이블의 모든 파티션을 검색해야 함
	3) 실제 레코드의 컬럼을 변경하는 작업의 절차는 UPDATE 쿼리가 어떤 컬럼 값을 변경하는지에 따라 큰 차이가 있음
		* 파티션 키 *이외의* 칼럼이 변경되는 경우
			* 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경됨
		* 파티션 키 컬럼이 변경되는 경우
			1) 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제
			2) 변경되는 파티션 키 칼럼의 표현식을 평가
			3) 2번의 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 저장
![파티션 키 칼럼이 변경되는 UPDATE 문장의 처리](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-05-25-23-34-56.jpeg)
#### 파티션 테이블의 검색
* 성능에 크게 영향을 미치는 요인
	* **where 절의 조건**으로 **검색해야 할 파티션을 선택**할 수 있는가?
	* **where 절의 조건**이 인덱스를 효율적으로 사용(**인덱스 레인지 스캔**) 할 수 있는가?
		* 이 내용은 파티션 테이블이 아닌 테이블에도 동일하게 적용됨
* 두 가지 요인들의 조합에 따른 실행
	* **파티션 선택 가능 + 인덱스 효율적 사용 가능**
		* 가장 효율적
		* 파티션 개수에 상관없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔
![가장 효율적인 방법](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.47.34.png)
	* **파티션 선택 불가 + 인덱스 효율적 사용 가능**
		* 모든 파티션을 대상으로 검색
		* 각 파티션에 대해서 인덱스 레인지 스캔 가능
		* 결론 : 테이블에 존재하는 모든 파티션 개수만큼 인덱스 레인지 스탬을 수행해서 검색
			* = 파티션 개수만큼의 테이블에 대해 인덱스 레인지 스탬을 한 다음 결과를 병합해서 가져오는 것과 동일
		* 테이블에 파티션 개수가 많을 때는 MySQL 서버의 부하가 높아지고 처리 시간도 느려지므로 조심
![파티션 선택 불가 + 인덱스 효율적 사용 가능](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.51.52.png)
	* **파티션 선택 가능 + 인덱스 효율적 사용 불가**
		* 필요한 파티션만 읽으면 됨
		* 인덱스는 사용 불가 = 파티션 테이블 풀 스캔
			* 레코드 수가 많다면 상당히 느리게 처리될 것임
		* 가능한 한 피해야 하는 방법
![파티션 선택 가능 + 인덱스 효율적 사용 불가](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.55.09.png)
	* **파티션 선택 불가 + 인덱스 효율적 사용 불가**
		* 모든 파티션 검색
		* 인덱스 사용 불가하므로 풀 스캔
		* 가능한 한 피해야 하는 방법
![파티션 선택 불가 + 인덱스 효율적 사용 불가](https://github.com/tatarobo/Study/blob/master/RealMysql/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-05-25%20%EC%98%A4%ED%9B%84%2011.57.21.png)
#### 파티션 테이블의 인덱스 스캔과 정렬
* MySQL의 파티션 테이블 인덱스 특징
	* 로컬 인덱스
	* **인덱스는 파티션 단위로 생성됨**
	* 파티션에 관계없이 테이블 전체 단위로 글로벌하게 **하나로 통합된 인덱스는 지원하지 않음**
*  예시
	* reg_userid 칼럼으로 만들어진 인데스가 어떻게 구성되고 인덱스도 연동별로 파티션되어 저장됨
![인덱스와 데이터를 읽는 방법](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-05-28-00-22-00.jpeg)
		* reg_userid 칼럼의 값은 파티션의 순서대로 정렬되지 않음
		* 즉, 파티션되지 않은 테이블에서 인덱스 순서대로 읽으면 정렬된 결과를 바로 얻을 수 있지만, 파티션된 테이블에서는 그렇지 않음
	* 여러개의 파티션을 읽어야 할 때 결과가 인덱스 칼럼으로 정렬될지에 대한 예제
```
CREATE TABLE tb_article (
 reg_userid VARCHAR(45) NOT NULL,
 article_id INT NOT NULL,
 reg_date DATETIME NOT NULL,
 PRIMARY KEY (reg_userid, reg_date)
)
PARTITION BY RANGE ( YEAR(reg_date) ) (
 PARTITION p2009 VALUES LESS THAN (2010),
 PARTITION p2010 VALUES LESS THAN (2011),
 PARTITION p2011 VALUES LESS THAN (2012),
 PARTITION p9999 VALUES LESS THAN MAXVALUE
);

insert into tb_article values 
('brew', 1001, '2009-01-01 00:00:00'),
('java', 1001, '2009-02-01 00:00:00'),
('toto', 1001, '2009-03-01 00:00:00'),
('brew', 1202, '2010-01-01 00:00:00'),
('java', 1203, '2010-02-01 00:00:00'),
('toto', 1209, '2010-03-01 00:00:00'),
('brew', 1821, '2011-01-01 00:00:00'),
('java', 1833, '2011-02-01 00:00:00'),
('toto', 1834, '2011-03-01 00:00:00');

SELECT * FROM tb_article 
WHERE reg_userid BETWEEN 'brew' AND 'toto'
ORDER BY reg_userid;
```
![select explain 결과](https://github.com/tatarobo/Study/blob/master/RealMysql/image/pic13-2.png)
* ㅇㅇ
* 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM3NzQ2MzkwNCwzNzgwNzU3NDAsODExMD
IxMzgwLDIxMjg5NzIwODIsLTcwMzg1ODEwMCwtMTc0MzI0OTg5
NCw2Nzc5MjUwOTYsLTEwNzAzNzI0MzMsLTEzMDA2MDY1NywtOT
g2MTUyMDA1LDcyODAzNDQ4OCw0MTk1ODkzLC0xMDI2NDE5OTc4
LDE5MjcwMTE1NzUsLTEzNTc1NzgyMDQsLTE4MzY3Njg5ODgsLT
ExMTMxMjc3OSwxNTA5NzY3NTk4XX0=
-->