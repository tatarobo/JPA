
# 5. 인덱스
## 5.1 디스크 읽기 방식
### 5.1.1 저장 매체
* 데이터를 저장할 수 있는 매체
	* 내장 디스크
	* DAS (Direct Attached Storage)
		* disk 만 존재. 컴퓨터에 연결해서 사용
		* 한 컴퓨터에만 연결할 수 있음 (여러 컴퓨터 공유 불가능)
	* NAS (Network Attached Storage)
		* 컴퓨터와 tcp/ip 를 통해 연결됨
		* 직접 연결 보다는 속도가 느림
	* SAN (Storage Area Network)
		* 광케이블롸 컴퓨터 본체와 연결
		* 여러 컴퓨터에서 접근 가능
		* 빠르지만, 비용이 많이 듦
### 5.1.2 디스크 드라이브와 솔리드 스테이트 드라이브 (SSD)
* SSD
	* 전자식 저장 매체
	* 기존 기계식 저장 매체인 디스크 대체용
	* DAS, SAN 에 그대로 이용 가능
	* 랜덤 I/O 에서 특히 디스크보다 성능이 빠르다
### 5.1.3 랜덤 I/O 와 순차 I/O
* 3개의 페이지 (16x3kb) 를 디스크에 기록하기 위해 
	* 순차 I/O는 1번 시스템 콜 요청
	* 랜덤 I/O 는 3번 요청
	* 랜던 I/O 작업이 훨씬 부하가 큼
* 쿼리 튜닝 = 랜덤 I/O 줄이는 것이 목적

> 참고
> * 인덱스 레인지 스캔 : 데이터를 읽기 위해 주로 랜덤 I/O 사용
> * 풀 테이블 스캔 : 순차 I/O 사용
> * 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있음

## 5.2 인덱스란?
* 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬하여 보관함
* 비유
	* sortedList
		* 인덱스. 저장된 값들을 항상 정렬 상태로 저장/유지
		* 저장 : 저장할 떄마다 정렬해야해서 복잡하고 느림
		* 찾기 : 이미 정렬되어 있으므로 빠름
		* **인덱스도 insert / update /delete 문장의 처리가 느림**
			* 즉, s*elect 쿼리 문장의 where 절에 사용된다고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고, 인덱스 크기가 비대해져 역효과*
	* arrayList
		* 데이터 파일. 저장되는 순서로 저장
* 인덱스 분류 (저자의 임의 분류)
	* 분류 방법 : 데이터를 관리하는 방식 (알고리즘) / 중복 값의 허용 여부 등
	* 인덱스를 역할별로 분류
		* 프라이머리 키 (primary key)
			* 그 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
			* 식별자라고도 불림
			* null 과 중복을 허용하지 않음
		* 보조키 (secondary key)
			* 프라이머리 키를 제외한 나머지 모든 인덱스
			* 유니크 인덱스
				* 프라이머리 키와 비슷
				* 프리이머리 키 대체 가능
				* 대체키라고도 함
	* 데이터 저장 방식(알고리즘) 별 분류 (대표적인 것들만 나열함)
		* B-Tree 인덱스
			* 가장 일반적으로 사용됨
			* 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
		* Hash 인덱스
			* 컬럼의 값으로 해시 값을 계산해서 인덱싱
			* 매우 빠른 검색 지원
			* 단점
				* 값을 변형해서 저장하므로, 전방(prefix) 일치와 같이 값의 일부만 검색하고자 할 때 사용할 수 없음
			* 메모리 기반의 db 에서 주로 사용됨
		* Fractal-Tree
			* B-Tree의 단점을 보완하기 위해 고안됨
			* 값을 변형하지 않고 인덱싱
			* 데이터 저장/삭제 시 처리 비용을 줄이도록 설계됨
	* 데이터 중복 허용 여부로 분류
		* 유니크 인덱스 (Unique)
			* 중복 여부 비허용
			* DBMS 옵티마이저에게 같은 것만 찾으면 더 이상 찾지 않아도 된다는 것을 알려주는 효과가 있음
		* 유니크하지 않은 인덱스 (Non-Unique)
	* 인덱스의 기능별로 분류
		* 전문 검색용
		* 공간 검색용
## 5.3 B-Tree 인덱스
* 일반적으로 B+-Tree 또는 B*-Tree 가 사용됨
* B 는 Binary 가 아니라 **Balanced** 임
* 원래 값을 변형시키지 않음 (앞 부분만 잘라서 관리하기는 함)
* 항상 정렬된 상태 유지
* 전문 검색 시에는 적합하지 않음
### 5.3.1 구조 및 특성
* 구조
	* 최상위 Root Node 존재
	* 하위에 자식 노드가 붙어 있는 구조
	* 리프 노드 : 트리 최하위 노드
	* 브렌치 노드 : 루트도 아니고 리프도 아닌 노드들
* 인덱스와 실제 데이터가 저장된 데이터는 따로 관리됨
* 인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있음
* ex) ![B-Tree 인덱스의 구조](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-00-22-33.jpeg)
	* 인덱스의 키 값을 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않음
	* **INSERT 순으로 저장되는 것 아님**
		* *UPDATE/ DELETE 없이 INSERT 만 수행한다면 순서대로 저장되는 것 맞음*
		* 레코드가 삭제되어 빈 공간이 생기면 그 다음 INSERT는 삭제된 공간을 재활용하도록 DBMS 가 설계되어 있음

> 참고
> * 대부분의 RDBMS 의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서대로 저장됨
> * InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장됨
> 	* 기본적으로 프라이머리 키 순서대로 정렬되어 저장됨
> 	* 오라클의 IOT, MS-SQL의 클러스터 테이블과 같은 구조
> * 다른 DBMS에서는 클러스터링 기능이 선택 사항

* 인덱스의 리프 노드와 데이터 파일의 관계
	* ![B-Tree의 리프 노드와 테이블 데이터 레코드](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-00-36-15.jpeg)
	* 레코드 주소
		* DBMS 종류나 MySQL 의 스토리지 엔진에 따라 달라짐
		* ex)
			* 오라클 : 물리적인 레코드 주소
			* MyISAM : 테이블에서 내부적인 레코드의 아이디(번호)를 의미
			* InnoDB : pk에 의해 클러스터링 됨. 즉, pk 값 자체가 주소 역할
	* **MySQL 테이블의 인덱스는 항상 인덱스 칼럼과 주소값의 조합으로 구성됨**
### 5.3.2 B-Tree 인덱스 키 추가 및 삭제
* 레코드 저장/변경하는 경우 인덱스 키 추가나 삭제 작업이 발생
#### 인덱스 키 추가
* 바로 인덱스에 저장될 수도 있고 그렇지 않을 수도 있음 (InnoDB)
* 저장될 위치 탐색
	* B-Tree 에 저장될 때는 저장될 키값을 이용해 B-Tree 상의 적절한 위치 탐색
	* 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree 의 리프 노드에 저장해야 함
	* 리프노드가 꽉 찬 경우
		* 리프 노드가 *분리 (split)* 되어야 함
		* 상위 브렌치 노드까지 처리의 범위가 넒어짐
	* 결론 : *B-Tree 는 상대적으로 쓰기 작업에 비용이 많이 듦*
* 인덱스 추가로 인한 INSERT/UPDATE 문장이 받을 영향
	* 계산 방법
		* 테이블에 레코드를 추가하는 작업 비용 : 1
		* 해당 테이블에 인덱스에 키를 추가하는 작업 비용 : 1~1.5
		* ex) 테이블에 인덱스가 3개(테이블의 모든 인덱스가 B-Tree 라고 가정)있다면 
			* 테이블에 인덱스가 하나도 없는 경우 작업 비용 : 1
			* 인덱스가 3개인 경우 작업 비용 : 5.5 (1.5 * 3 + 1)
	* 중요한 점 : **디스크로부터 인덱스 페이지를 읽고 써야 하기 때문에 시간이 오래 걸리는 것**
	* MyISAM 이나 메모리 스토리지 엔진은 INSERT 문장이 주어지면 바로 B-Tree에 인덱스 반영
		* B-Tree 에 키를 추가하는 작업이 완료될 때까지 클라이언트는 쿼리의 결과를 받지 못하고 기다려야 함
* ![INSERT 버퍼의 처리](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-01-21-05.jpeg)
	* 1. 사용자의 쿼리 실행
	* 2. InnoDB 의 ***버퍼 풀*에 새로운 키값을 추가해야 할 페이지 (B-Tree의 리프 노드)가 존재한다면 즉시 키 추가**
	* 3. 버퍼 풀에 B-Tree 의 리프 노드가 없으면 **인서트 버퍼**에 추가할 키 값과 레코드의 주소를 임시로 기록해 두고 작업 완료 (사용자 쿼리 실행 완료)
	* 4. *백그라운드 작업*으로 인덱스 페이지를 읽을 때마다 *인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인 후, 있으면 병합* (B-Tree 에 인덱스 키와 주소 값을 저장)
	* 5. DB 서버 자원에 *여유가 생기면* MySQL 서버의 *인서트 버퍼 머지 스레드*가 조금씩 **인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지** (B-Tree에 인덱스 키와 주소 저장)
* insert 버퍼
	* MySQL 5.1 이하
		* INSERT 로 인한 인덱스 키 추가 작업만 버퍼링 및 지연 처리 가능
		* 인서트 버퍼링 (Insert Buffering)
			* 자동으로 적용되는 기능
	* MySQL 5.5 이상
		* INSERT/DELETE 등에 의한 것도 처리 가능
		* 체인지 버퍼링 (Change Buffering)
		* innodb_change_buffering (관련 설정 파라미터)
			* 해당 값을 잉
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIyOTM2ODU2MiwxODQ4NTIzODEsODE1Nj
gwMzg0LC00Mjc2NjI0MDksLTE1NjM1MDcxNywtMTk3NDAyOTQz
NywxODgzMDE4MDgyLDExODcxNjY5OTcsMTI1NTA5NTU3MSwxMj
k0NjE5MjY1LC0xMDU5NTY2MTEzXX0=
-->