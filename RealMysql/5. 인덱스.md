
# 인덱스
## 디스크 읽기 방식
### 저장 매체
* 데이터를 저장할 수 있는 매체
	* 내장 디스크
	* DAS (Direct Attached Storage)
		* disk 만 존재. 컴퓨터에 연결해서 사용
		* 한 컴퓨터에만 연결할 수 있음 (여러 컴퓨터 공유 불가능)
	* NAS (Network Attached Storage)
		* 컴퓨터와 tcp/ip 를 통해 연결됨
		* 직접 연결 보다는 속도가 느림
	* SAN (Storage Area Network)
		* 광케이블롸 컴퓨터 본체와 연결
		* 여러 컴퓨터에서 접근 가능
		* 빠르지만, 비용이 많이 듦
### 디스크 드라이브와 솔리드 스테이트 드라이브 (SSD)
* SSD
	* 전자식 저장 매체
	* 기존 기계식 저장 매체인 디스크 대체용
	* DAS, SAN 에 그대로 이용 가능
	* 랜덤 I/O 에서 특히 디스크보다 성능이 빠르다
### 랜덤 I/O 와 순차 I/O
* 3개의 페이지 (16x3kb) 를 디스크에 기록하기 위해 
	* 순차 I/O는 1번 시스템 콜 요청
	* 랜덤 I/O 는 3번 요청
	* 랜던 I/O 작업이 훨씬 부하가 큼
* 쿼리 튜닝 = 랜덤 I/O 줄이는 것이 목적

> 참고
> * 인덱스 레인지 스캔 : 데이터를 읽기 위해 주로 랜덤 I/O 사용
> * 풀 테이블 스캔 : 순차 I/O 사용
> * 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있음

## 인덱스란?
* 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬하여 보관함
* 비유
	* sortedList
		* 인덱스. 저장된 값들을 항상 정렬 상태로 저장/유지
		* 저장 : 저장할 떄마다 정렬해야해서 복잡하고 느림
		* 찾기 : 이미 정렬되어 있으므로 빠름
		* **인덱스도 insert / update /delete 문장의 처리가 느림**
			* 즉, s*elect 쿼리 문장의 where 절에 사용된다고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고, 인덱스 크기가 비대해져 역효과*
	* arrayList
		* 데이터 파일. 저장되는 순서로 저장
* 인덱스 분류 (저자의 임의 분류)
	* 분류 방법 : 데이터를 관리하는 방식 (알고리즘) / 중복 값의 허용 여부 등
	* 인덱스를 역할별로 분류
		* 프라이머리 키 (primary key)
			* 그 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
			* 식별자라고도 불림
			* null 과 중복을 허용하지 않음
		* 보조키 (secondary key)
			* 프라이머리 키를 제외한 나머지 모든 인덱스
			* 유니크 인덱스
				* 프라이머리 키와 비슷
				* 프리이머리 키 대체 가능
				* 대체키라고도 함
	* 데이터 저장 방식(알고리즘) 별 분류 (대표적인 것들만 나열함)
		* B-Tree 인덱스
			* 가장 일반적으로 사용됨
			* 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
		* Hash 인덱스
			* 컬럼의 값으로 해시 값을 계산해서 인덱싱
			* 매우 빠른 검색 지원
			* 단점
				* 값을 변형해서 저장하므로, 전방(prefix) 일치와 같이 값의 일부만 검색하고자 할 때 사용할 수 없음
			* 메모리 기반의 db 에서 주로 사용됨
		* Fractal-Tree
			* B-Tree의 단점을 보완하기 위해 고안됨
			* 값을 변형하지 않고 인덱싱
			* 데이터 저장/삭제 시 처리 비용을 줄이도록 설계됨
	* 데이터 중복 허용 여부로 분류
		* 유니크 인덱스 (Unique)
			* 
		* 유니크하지 않은 인덱스 (Non-Unique)

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA0OTkxMzg2OCwxMTg3MTY2OTk3LDEyNT
UwOTU1NzEsMTI5NDYxOTI2NSwtMTA1OTU2NjExM119
-->