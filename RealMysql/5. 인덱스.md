
# 5. 인덱스
## 5.1 디스크 읽기 방식
### 5.1.1 저장 매체
* 데이터를 저장할 수 있는 매체
	* 내장 디스크
	* DAS (Direct Attached Storage)
		* disk 만 존재. 컴퓨터에 연결해서 사용
		* 한 컴퓨터에만 연결할 수 있음 (여러 컴퓨터 공유 불가능)
	* NAS (Network Attached Storage)
		* 컴퓨터와 tcp/ip 를 통해 연결됨
		* 직접 연결 보다는 속도가 느림
	* SAN (Storage Area Network)
		* 광케이블롸 컴퓨터 본체와 연결
		* 여러 컴퓨터에서 접근 가능
		* 빠르지만, 비용이 많이 듦
### 5.1.2 디스크 드라이브와 솔리드 스테이트 드라이브 (SSD)
* SSD
	* 전자식 저장 매체
	* 기존 기계식 저장 매체인 디스크 대체용
	* DAS, SAN 에 그대로 이용 가능
	* 랜덤 I/O 에서 특히 디스크보다 성능이 빠르다
### 5.1.3 랜덤 I/O 와 순차 I/O
* 3개의 페이지 (16x3kb) 를 디스크에 기록하기 위해 
	* 순차 I/O는 1번 시스템 콜 요청
	* 랜덤 I/O 는 3번 요청
	* 랜던 I/O 작업이 훨씬 부하가 큼
* 쿼리 튜닝 = 랜덤 I/O 줄이는 것이 목적

> 참고
> * 인덱스 레인지 스캔 : 데이터를 읽기 위해 주로 랜덤 I/O 사용
> * 풀 테이블 스캔 : 순차 I/O 사용
> * 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있음

## 5.2 인덱스란?
* 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬하여 보관함
* 비유
	* sortedList
		* 인덱스. 저장된 값들을 항상 정렬 상태로 저장/유지
		* 저장 : 저장할 떄마다 정렬해야해서 복잡하고 느림
		* 찾기 : 이미 정렬되어 있으므로 빠름
		* **인덱스도 insert / update /delete 문장의 처리가 느림**
			* 즉, s*elect 쿼리 문장의 where 절에 사용된다고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고, 인덱스 크기가 비대해져 역효과*
	* arrayList
		* 데이터 파일. 저장되는 순서로 저장
* 인덱스 분류 (저자의 임의 분류)
	* 분류 방법 : 데이터를 관리하는 방식 (알고리즘) / 중복 값의 허용 여부 등
	* 인덱스를 역할별로 분류
		* 프라이머리 키 (primary key)
			* 그 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
			* 식별자라고도 불림
			* null 과 중복을 허용하지 않음
		* 보조키 (secondary key)
			* 프라이머리 키를 제외한 나머지 모든 인덱스
			* 유니크 인덱스
				* 프라이머리 키와 비슷
				* 프리이머리 키 대체 가능
				* 대체키라고도 함
	* 데이터 저장 방식(알고리즘) 별 분류 (대표적인 것들만 나열함)
		* B-Tree 인덱스
			* 가장 일반적으로 사용됨
			* 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
		* Hash 인덱스
			* 컬럼의 값으로 해시 값을 계산해서 인덱싱
			* 매우 빠른 검색 지원
			* 단점
				* 값을 변형해서 저장하므로, 전방(prefix) 일치와 같이 값의 일부만 검색하고자 할 때 사용할 수 없음
			* 메모리 기반의 db 에서 주로 사용됨
		* Fractal-Tree
			* B-Tree의 단점을 보완하기 위해 고안됨
			* 값을 변형하지 않고 인덱싱
			* 데이터 저장/삭제 시 처리 비용을 줄이도록 설계됨
	* 데이터 중복 허용 여부로 분류
		* 유니크 인덱스 (Unique)
			* 중복 여부 비허용
			* DBMS 옵티마이저에게 같은 것만 찾으면 더 이상 찾지 않아도 된다는 것을 알려주는 효과가 있음
		* 유니크하지 않은 인덱스 (Non-Unique)
	* 인덱스의 기능별로 분류
		* 전문 검색용
		* 공간 검색용
## 5.3 B-Tree 인덱스
* 일반적으로 B+-Tree 또는 B*-Tree 가 사용됨
* B 는 Binary 가 아니라 **Balanced** 임
* 원래 값을 변형시키지 않음 (앞 부분만 잘라서 관리하기는 함)
* 항상 정렬된 상태 유지
* 전문 검색 시에는 적합하지 않음
### 5.3.1 구조 및 특성
* 구조
	* 최상위 Root Node 존재
	* 하위에 자식 노드가 붙어 있는 구조
	* 리프 노드 : 트리 최하위 노드
	* 브렌치 노드 : 루트도 아니고 리프도 아닌 노드들
* 인덱스와 실제 데이터가 저장된 데이터는 따로 관리됨
* 인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있음
* ex) ![B-Tree 인덱스의 구조](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-00-22-33.jpeg)
	* 인덱스의 키 값을 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않음
	* **INSERT 순으로 저장되는 것 아님**
		* *UPDATE/ DELETE 없이 INSERT 만 수행한다면 순서대로 저장되는 것 맞음*
		* 레코드가 삭제되어 빈 공간이 생기면 그 다음 INSERT는 삭제된 공간을 재활용하도록 DBMS 가 설계되어 있음

> 참고
> * 대부분의 RDBMS 의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서대로 저장됨
> * InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장됨
> 	* 기본적으로 프라이머리 키 순서대로 정렬되어 저장됨
> 	* 오라클의 IOT, MS-SQL의 클러스터 테이블과 같은 구조
> * 다른 DBMS에서는 클러스터링 기능이 선택 사항

* 인덱스의 리프 노드와 데이터 파일의 관계
	* ![B-Tree의 리프 노드와 테이블 데이터 레코드](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-00-36-15.jpeg)
	* 레코드 주소
		* DBMS 종류나 MySQL 의 스토리지 엔진에 따라 달라짐
		* ex)
			* 오라클 : 물리적인 레코드 주소
			* MyISAM : 테이블에서 내부적인 레코드의 아이디(번호)를 의미
			* InnoDB : pk에 의해 클러스터링 됨. 즉, pk 값 자체가 주소 역할
	* **MySQL 테이블의 인덱스는 항상 인덱스 칼럼과 주소값의 조합으로 구성됨**
### 5.3.2 B-Tree 인덱스 키 추가 및 삭제
* 레코드 저장/변경하는 경우 인덱스 키 추가나 삭제 작업이 발생
#### 인덱스 키 추가
* 바로 인덱스에 저장될 수도 있고 그렇지 않을 수도 있음
* 저장될 위치 탐색
	* B-Tree 에 저장될 때는 저장될 키값을 이용해 B-Tree 상의 적절한 위치 탐색
	* 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree 의 리프 노드에 저장해야 함
	* 리프노드가 꽉 찬 경우
		* 리프 노드가 *분리 (split)* 되어야 함
		* 상위 브렌치 노드까지 처리의 범위가 넒어짐
	* 결론 : *B-Tree 는 상대적으로 쓰기 작업에 비용이 많이 듦*
* 인덱스 추가로 인한 INSERT/UPDATE 문장이 받을 영향
	* 계산 방법 : 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwNDIxNzE0NTIsLTE1NjM1MDcxNywtMT
k3NDAyOTQzNywxODgzMDE4MDgyLDExODcxNjY5OTcsMTI1NTA5
NTU3MSwxMjk0NjE5MjY1LC0xMDU5NTY2MTEzXX0=
-->