

# 5. 인덱스
## 5.1 디스크 읽기 방식
### 5.1.1 저장 매체
* 데이터를 저장할 수 있는 매체
	* 내장 디스크
	* DAS (Direct Attached Storage)
		* disk 만 존재. 컴퓨터에 연결해서 사용
		* 한 컴퓨터에만 연결할 수 있음 (여러 컴퓨터 공유 불가능)
	* NAS (Network Attached Storage)
		* 컴퓨터와 tcp/ip 를 통해 연결됨
		* 직접 연결 보다는 속도가 느림
	* SAN (Storage Area Network)
		* 광케이블롸 컴퓨터 본체와 연결
		* 여러 컴퓨터에서 접근 가능
		* 빠르지만, 비용이 많이 듦
### 5.1.2 디스크 드라이브와 솔리드 스테이트 드라이브 (SSD)
* SSD
	* 전자식 저장 매체
	* 기존 기계식 저장 매체인 디스크 대체용
	* DAS, SAN 에 그대로 이용 가능
	* 랜덤 I/O 에서 특히 디스크보다 성능이 빠르다
### 5.1.3 랜덤 I/O 와 순차 I/O
* 3개의 페이지 (16x3kb) 를 디스크에 기록하기 위해 
	* 순차 I/O는 1번 시스템 콜 요청
	* 랜덤 I/O 는 3번 요청
	* 랜던 I/O 작업이 훨씬 부하가 큼
* 쿼리 튜닝 = 랜덤 I/O 줄이는 것이 목적

> 참고
> * 인덱스 레인지 스캔 : 데이터를 읽기 위해 주로 랜덤 I/O 사용
> * 풀 테이블 스캔 : 순차 I/O 사용
> * 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있음

## 5.2 인덱스란?
* 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬하여 보관함
* 비유
	* sortedList
		* 인덱스. 저장된 값들을 항상 정렬 상태로 저장/유지
		* 저장 : 저장할 떄마다 정렬해야해서 복잡하고 느림
		* 찾기 : 이미 정렬되어 있으므로 빠름
		* **인덱스도 insert / update /delete 문장의 처리가 느림**
			* 즉, s*elect 쿼리 문장의 where 절에 사용된다고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고, 인덱스 크기가 비대해져 역효과*
	* arrayList
		* 데이터 파일. 저장되는 순서로 저장
* 인덱스 분류 (저자의 임의 분류)
	* 분류 방법 : 데이터를 관리하는 방식 (알고리즘) / 중복 값의 허용 여부 등
	* 인덱스를 역할별로 분류
		* 프라이머리 키 (primary key)
			* 그 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
			* 식별자라고도 불림
			* null 과 중복을 허용하지 않음
		* 보조키 (secondary key)
			* 프라이머리 키를 제외한 나머지 모든 인덱스
			* 유니크 인덱스
				* 프라이머리 키와 비슷
				* 프리이머리 키 대체 가능
				* 대체키라고도 함
	* 데이터 저장 방식(알고리즘) 별 분류 (대표적인 것들만 나열함)
		* B-Tree 인덱스
			* 가장 일반적으로 사용됨
			* 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
		* Hash 인덱스
			* 컬럼의 값으로 해시 값을 계산해서 인덱싱
			* 매우 빠른 검색 지원
			* 단점
				* 값을 변형해서 저장하므로, 전방(prefix) 일치와 같이 값의 일부만 검색하고자 할 때 사용할 수 없음
			* 메모리 기반의 db 에서 주로 사용됨
		* Fractal-Tree
			* B-Tree의 단점을 보완하기 위해 고안됨
			* 값을 변형하지 않고 인덱싱
			* 데이터 저장/삭제 시 처리 비용을 줄이도록 설계됨
	* 데이터 중복 허용 여부로 분류
		* 유니크 인덱스 (Unique)
			* 중복 여부 비허용
			* DBMS 옵티마이저에게 같은 것만 찾으면 더 이상 찾지 않아도 된다는 것을 알려주는 효과가 있음
		* 유니크하지 않은 인덱스 (Non-Unique)
	* 인덱스의 기능별로 분류
		* 전문 검색용
		* 공간 검색용
## 5.3 B-Tree 인덱스
* 일반적으로 B+-Tree 또는 B*-Tree 가 사용됨
* B 는 Binary 가 아니라 **Balanced** 임
* 원래 값을 변형시키지 않음 (앞 부분만 잘라서 관리하기는 함)
* 항상 정렬된 상태 유지
* 전문 검색 시에는 적합하지 않음
### 5.3.1 구조 및 특성
* 구조
	* 최상위 Root Node 존재
	* 하위에 자식 노드가 붙어 있는 구조
	* 리프 노드 : 트리 최하위 노드
	* 브렌치 노드 : 루트도 아니고 리프도 아닌 노드들
* 인덱스와 실제 데이터가 저장된 데이터는 따로 관리됨
* 인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있음
* ex) ![B-Tree 인덱스의 구조](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-00-22-33.jpeg)
	* 인덱스의 키 값을 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않음
	* **INSERT 순으로 저장되는 것 아님**
		* *UPDATE/ DELETE 없이 INSERT 만 수행한다면 순서대로 저장되는 것 맞음*
		* 레코드가 삭제되어 빈 공간이 생기면 그 다음 INSERT는 삭제된 공간을 재활용하도록 DBMS 가 설계되어 있음

> 참고
> * 대부분의 RDBMS 의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서대로 저장됨
> * InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장됨
> 	* 기본적으로 프라이머리 키 순서대로 정렬되어 저장됨
> 	* 오라클의 IOT, MS-SQL의 클러스터 테이블과 같은 구조
> * 다른 DBMS에서는 클러스터링 기능이 선택 사항

* 인덱스의 리프 노드와 데이터 파일의 관계
	* ![B-Tree의 리프 노드와 테이블 데이터 레코드](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-00-36-15.jpeg)
	* 레코드 주소
		* DBMS 종류나 MySQL 의 스토리지 엔진에 따라 달라짐
		* ex)
			* 오라클 : 물리적인 레코드 주소
			* MyISAM : 테이블에서 내부적인 레코드의 아이디(번호)를 의미
			* InnoDB : pk에 의해 클러스터링 됨. 즉, pk 값 자체가 주소 역할
	* **MySQL 테이블의 인덱스는 항상 인덱스 칼럼과 주소값의 조합으로 구성됨**
### 5.3.2 B-Tree 인덱스 키 추가 및 삭제
* 레코드 저장/변경하는 경우 인덱스 키 추가나 삭제 작업이 발생
#### 인덱스 키 추가
* 바로 인덱스에 저장될 수도 있고 그렇지 않을 수도 있음 (InnoDB)
* 저장될 위치 탐색
	* B-Tree 에 저장될 때는 저장될 키값을 이용해 B-Tree 상의 적절한 위치 탐색
	* 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree 의 리프 노드에 저장해야 함
	* 리프노드가 꽉 찬 경우
		* 리프 노드가 *분리 (split)* 되어야 함
		* 상위 브렌치 노드까지 처리의 범위가 넒어짐
	* 결론 : *B-Tree 는 상대적으로 쓰기 작업에 비용이 많이 듦*
* 인덱스 추가로 인한 INSERT/UPDATE 문장이 받을 영향
	* 계산 방법
		* 테이블에 레코드를 추가하는 작업 비용 : 1
		* 해당 테이블에 인덱스에 키를 추가하는 작업 비용 : 1~1.5
		* ex) 테이블에 인덱스가 3개(테이블의 모든 인덱스가 B-Tree 라고 가정)있다면 
			* 테이블에 인덱스가 하나도 없는 경우 작업 비용 : 1
			* 인덱스가 3개인 경우 작업 비용 : 5.5 (1.5 * 3 + 1)
	* 중요한 점 : **디스크로부터 인덱스 페이지를 읽고 써야 하기 때문에 시간이 오래 걸리는 것**
	* MyISAM 이나 메모리 스토리지 엔진은 INSERT 문장이 주어지면 바로 B-Tree에 인덱스 반영
		* B-Tree 에 키를 추가하는 작업이 완료될 때까지 클라이언트는 쿼리의 결과를 받지 못하고 기다려야 함
* ![INSERT 버퍼의 처리](https://github.com/tatarobo/Study/blob/master/RealMysql/image/KakaoTalk_Image_2021-04-19-01-21-05.jpeg)
	* 1. 사용자의 쿼리 실행
	* 2. InnoDB 의 ***버퍼 풀*에 새로운 키값을 추가해야 할 페이지 (B-Tree의 리프 노드)가 존재한다면 즉시 키 추가**
	* 3. 버퍼 풀에 B-Tree 의 리프 노드가 없으면 **인서트 버퍼**에 추가할 키 값과 레코드의 주소를 임시로 기록해 두고 작업 완료 (사용자 쿼리 실행 완료)
	* 4. *백그라운드 작업*으로 인덱스 페이지를 읽을 때마다 *인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인 후, 있으면 병합* (B-Tree 에 인덱스 키와 주소 값을 저장)
	* 5. DB 서버 자원에 *여유가 생기면* MySQL 서버의 *인서트 버퍼 머지 스레드*가 조금씩 **인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지** (B-Tree에 인덱스 키와 주소 저장)
* insert 버퍼
	* MySQL 5.1 이하
		* INSERT 로 인한 인덱스 키 추가 작업만 버퍼링 및 지연 처리 가능
		* 인서트 버퍼링 (Insert Buffering)
			* 자동으로 적용되는 기능
	* MySQL 5.5 이상
		* INSERT/DELETE 등에 의한 것도 처리 가능
		* 체인지 버퍼링 (Change Buffering)
		* innodb_change_buffering (관련 설정 파라미터)
			* 해당 값을 이용해서 키 추가 작업과 키 삭제 작업 중 어느 것을 지연 처리할지 설정해야 함
#### 인덱스 키 삭제
* 해당 키 값이 저장된 B-Tree 의 리프 노드를 찾아서 그냥 **삭제 마크만 하면 작업이 완료**됨
	* 삭제된 공간은 방치 or 재활용됨
	* 마킹 작업도 디스크 쓰기가 필요 -> 디스트 I/O 가 필요한 작업
* MySQL 5.5 이상의 버전에서는 이 작업 또한 버퍼링되어 지연 처리가 될 수 있음
	* 처리가 지연되어도 사용자에게는 특별한 악영향 없음
	* MySQL 서버가 내부 처리함
* MyISAM 이나 Memory 스토리지 엔진의 테이블에서는 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료됨
#### 인덱스 키 변경
* 값에 따라 저장될 리프 노드의 위치가 결정됨
* B-Tree 의 키값이 변경되는 경우에는 단순히 인덱스상의 키값만 변경하는 것은 불가능
* B-Tree의 키값 변경 작업
	* 먼저 키 값 삭제
	* 다시 새로운 키 값 추가
#### 인덱스 키 검색
* B-Tree를 이용한 검색
	* 100% 일치하는 경우
	* 앞부분(left-most part) 만 일치하는 경우
	* **부등호("<>") 비교나 값의 뒷부분 비교는 B-Tree 인덱스를 이용한 검색이 불가능**

> << 주의 >>
> * 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아님
> * **즉, *함수나 연산을 수행한 결과*로 정렬/검색하는 작업은 B-Tree의 장점 이용 불가능**
* InnoDB의 경우
	* 레코드 잠금, 넥스트 키 락(갭 락) 이 검색을 수행한 **인덱스를 잠근 후 테이블의 레코드를 잠그는 식**으로 동작
	* 즉, UPDATE 나 DELETE 수행 시 적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 됨
### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
* 인덱스를 구성하는 컬럼의 크기
* 레코드의 건수
* 유니크안 인덱스 키 값의 개수
#### 인덱스 키 값의 크기
* InnoDB 에서 디스크에 데이터를 쓰는 가장 기본 단위 : **페이지 (Page) 또는 블록 (Block)**
	* 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 됨
	* 인덱스도 페이지 단위로 관리됨
		* 루트, 브렌치, 리프 노드를 구분한 기준이 페이지
* B-Tree 의 자식 노드 개수는 가변적. *페이지 크기*와 *키 값 크기*에 따라 자식 노드 수가 결정됨
	* ex) 인덱스의 크기 = 16byte, 자식 노드 주소 영역 = 12byte, 인덱스 페이지 하나 크기 (16kb)
		* 16*1024(16+12) = 585 개의 자식노드를 가질 수 있음
	* ex) 인덱스의 크기 = 32 byte, 자식 노드 주소 영역 = 12byte, 인덱스 페이지 하나 크기 (16kb)
		* 16*1024(32+12) = 372 개의 자식노드를 가질 수 있음
	* 결론
		* 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어남 = 그만큼 느려짐
		* 인덱스 키 값의 길이가 길어짐 = 전체적인 인덱스 크기가 커짐 = 인덱스를 캐시해 두는 innoDB의 버퍼풀이나 MyISAM 의 키 캐시 영역에 보관할 수 있는 레코드 개수가 줄어듦 = 메모리 효율이 떨어짐
#### B-Tree 깊이
* 직접적으로 제어할 방법 없음
* B-Tree 깊이는 MySQL 에서 값을 검색할 때 **몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제**
* ex) B-Tree의 깊이가 3인 경우
	* 키값이 16byte 인 경우 2억(585 * 585 * 585) 개 정도의 키값을 담을 수 있음
	* 키값이 32byte 인 경우 5천만 (372 * 372 * 372) 개  정도의 키 값을 담을 수 있음
	* 결론 : 인덱스의 키 값이 커질 수록 디스크 읽기가 더 많이 필요하게 됨
#### 선택도 (기수성)
* **모든 인덱스 키값 가운데 유니크한 값의 수**
	* ex) 전체 인덱스 키값 : 100개, 유니크한 값 : 10개 => 기수성 : 10
* 중복값이 많아지면 기수성은 낮아지고 동시에 선택도도 떨어짐
* **선택도가 높을수록 검색 대상이 줄어들기 때문에 속도가 빨라짐**
> (( 참고 ))
> 선택도가 좋지 않더라도 정렬이나 그룹핑을 위해 인덱스를 만드는 것이 나은 경우도 있음
* ex) 1만개의 레코드. county 만 인덱스
	* case A : country 컬럼의 유니크 값이 10개
		* 평균 1000건을 읽음 (10 * 1000 = 10000)
		* 만족하는 레코드가 1개라면 1개를 위해 999개를 더 읽은 격
	* case B : country 컬럼의 유니크 값이 1000개
		* 편균 10건을 읽음 (1000 * 10 = 10000)
		* 만족하는 레코드가 1개라면 1개를 위해 9개를 더 읽은 격
#### 읽어야 하는 레코드의 건수
* 인덱스를 통해서 테이블의 레코드를 읽는 비용 > 바로 테이블의 레코드를 읽는 비용
	* 대략 4~5배 정도의 비용이 더 듦
* 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 **20~25%**를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식(필터링)이 더 효율적
### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기
#### 인덱스 레인지 스캔
* **검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식**
* 만약 스캔하다가 리프 노드의 끝까지 다 읽으면 *리프 노드 간의 링크*를 이용해 다음 리프 노드를 찾아서 다시 스캔함
* 스캔 마지막 위치에 다다르면 사용자에게 레코드 반환
* 실제 레코드를 가져올 때는 **레코드 한건 단위로 랜덤 I/O 가 한번씩 실행**됨
	* 그래서 인덱스를 통해 레코드를 읽는 것이 비용이 큰 작업이라는 것
#### 인덱스 풀 스캔
* **인덱스의 처음부터 끝까지 모두 읽는 방식**
* 대표적으로, 쿼리의 조건절에 사용된 컬럼이 ***인덱스의 첫 컬럼이 아닌 경우*** 발생
	* ex) 인덱스는 A, B, C 컬럼 순으로 만들어져 있지만 쿼리의 조건절은 B나 C 컬럼으로 검색하는 경우
* 일반적으로 인덱스가 테이블보다 크기가 작아서 인덱스를 다 읽는게 테이블을 다 읽는 것보다 효율적임
* **쿼리가 인덱스에 명시된 컬럼 만으로 조건을 처리할 수 있는 경우** 주로 사용됨
* 인덱스 뿐만 아니라 레코드까지 모두 읽어야 한다면 이 방식으로 처리하지 않음
* 효율성
	* 인덱스 레인지 스캔 > 인덱스 풀 스캔 > 테이블 풀 스캔
* 인덱스를 효율적으로 사용하는 방법은 아님
#### 루스 인덱스 스캔
* **느슨하게 인덱스를 검색하는 방법**
	* Oracle의 인덱스 스킵 스캔과 비슷
* 동작
	* 인덱스 레인지 스캔과 비슷
	* 차이점 : 중간마다 필요치 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리됨
* 사용
	* GroupBy, Max(), Min() 에 대해 최적화를 하는 경우 사용됨
	* ex) 
		* `SELECT dept_no, MIN(emp_no) FROM dept_emp WHERE dept_no BETWEEN 'd002' AND 'd004' GROUP BY dept_no;`
		* group by 때문에 dept_no 그룹별로 제일 첫번째 코드만 읽으면 된다는 것을 옵티마이저가 알고 있음
### 5.3.5 다중 컬럼 (Multi-coloum) 인덱스
* 2개 이상 컬럼으로 구성된 인덱스
* 정렬
	* 인덱스의 두번째 칼럼은 첫번째 컬럼에 의존해서 정렬됨
	* **즉, 두번째 컬럼은 첫번째 컬림이 똑같은 레코드에서만 의미가 있음**
	* 4개가 묶여 있으면, 첫번째 <-(의존)- 두번째 <-(의존)- 세번째 <-(의존)- 네번째 이렇게 의존함
### 5.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
#### 인덱스의 정렬
* MySQL 은 컬럼 단위로 정렬 방식(ASC / DESC)을 혼합해서 생성하는 기능을 지원하지 않음
	* 해당 쿼리를 실행하면 문제가 발생하진 않지만, 실제로는 ASC 로만 정렬되게 됨
* 오름차순, 내림차순을 혼합하려면 칼럼의 값을 역으로 변환해서 구현하는 것이 유일한 방법
	* ex) ranking 테이블에서 team_name 칼럼은 오름차순, user_score는 높은 점수 순서대로 정렬하고 싶음
		* 테이블
		`CREATE TABLE ranking (
			team_name varchar(20),
			user_name varchar(20),
			user_score int,
			...
			index ix_teamname_userscore(team_name, user_score)
		);`
		* 쿼리
		`SELECT team_name, user_name
		FROM ranking
		ORDER BY team_name ASC, user_score DESC;`
			* 위 쿼리를 사용하면 원하는 결과를 조회는 가능
			* 그러나, 최종 단계에서 레코드를 정렬하는 과정이 필요함 -> 빠른 처리 불가능
			* 해결방법 : user_score 값을 역으로 변환해서 저장 = 즉, 마이너스(-) 부호를 붙여서 저장
				`SELECT team_name, user_name
		FROM ranking
		ORDER BY team_name ASC, user_score ASC;`
#### 인덱스 스캔 방향
* 아래와 같은 경우 동작 방식
	`SELECT * FROM employees ORDER BY first_name DESC LIMIT 1;`
	* **이때 인덱스를 끝까지 읽지 않고, 옵티마이저에 의해 맨 끝으로 역순으로 접근해 1개를 읽어옴**
* 인덱스를 역순으로 정렬은 불가능하지만, 읽는 방향에 따라 오름차순/내림차순 정렬 효과를 얻을 수 있음
* *MIN(), MAX() 함수 등의 최적화*가 필요한 경우 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만듦
### 5.3.7 B-Tree 인덱스의 가용성과 효율성
#### 비교 조건의 종류와 효율성
* 다중 칼럼 인덱스
	* 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 조건 (=) 인지 범위 조건 (<, >) 인지에 따라 인덱스 칼럼 활용 형태 및 효율성이 달라짐
`SELECT * FROM dept_emp WHERE dept_no = 'd002' AND emp_no >= 10114;`
	* case A : dept_no + emp_no
		* 원하는 결과를 단번에 가져온다
		* **작업 범위 결정 조건**
			* 이 경우 dept_no 컬럼과 emp_no 컬럼 모두 해당
	* case B : emp_no + dept_no
		* emp_no 가 먼저 정렬되어 있으므로 쓸데없는 정보도 같이 가져오게 된다
		* **필터링 조건 (or 체크 조건)**
			* 이 경우 emp_no 만 작업 범위 결정 조건이고 , dept_no 는 필터링 조건임
	* 작업 범위 결정 조건은 많을수록 빨라짐
	* 필터링 조건은 많다고 해서 쿼리 성능을 높이진 못함
#### 인덱스의 가용성
* B-Tree 인덱스 특징
	* **왼쪽 값을 기준(left-most)으로 오른쪽 값이 정렬되어 있음**
	* 왼쪽 중심은 다중 컬럼 인덱스의 칼럼에 대해서도 함께 적용됨
* ex) `SELECT * FROM employees WHERE first_name LIKE '%mer';`
	* 레인지 스캔 방식 사용 불가능
	* 왼쪽부터 한글자씩 비교해 가면서 일치하는 레코드를 찾는 방식이기 떄문
* ex2) `SELECT * FROM dept_emp WHERE emp_no >= 10144;`
	* 인덱스가 dept_no, emp_no 칼럼 순으로 생성되어 있으면 인덱스의 선행 컬럼인 dept_no 값 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용 불가능
	* GROUP BY 나 ORDER BY 에서도 똑같음
#### 가용성과 효율성 판단
* 작업 범위 결정 조건으로 사용할 수 없는 경우 (경우에 따라서는 체크 조건으로 인덱스 사용 가능)
	* **NOT-EQUAL 로 비교된 경우** ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
	* **LIKE '%??'** (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
	* stored 함수나 다른 연산자로 **인덱스 컬럼이 변형된 후 비교된 경우**
		* WHERE SUBSTRING(column, 1, 1) = 'X'
		* WHERE DAYOFMONTH(column) = 1
	* **NON-DETERMINISTIC** 속성의 stored 함수가 비교 조건에 사용된 경우
		* WHERE column = deterministic_function()
	* 문자열 데이터 타입의 **콜레이션이 다른 경우**
		* WHERE utf8_bin_char_column = euckr_bin_char_column
* MySQL 에서는 NULL도 인덱스로 관리됨
	* ex) `..WHERE column IS NULL ...` 도 작업 범위 결정 조건으로 인덱스 사용
* 다중 컬럼 인덱스의 경우
	* `INDEX ix_test(column_1, column_2, ..., column_n)`
		* 작업범위 결정 조건으로 인덱스를 사용하지 못하는 경우
			* column_1 컬럼에 대한 조건이 없는 경우
			* column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
		* 작업 범위 결정 조건으로 사용하는 경우 (i > 2 and i < n)
			* column_1 ~ column_(i-1) 까지 Equal 형태 ('=' or 'IN')로 비교
			* column_i 컬럼에 대해 다음 연산자중 하나로 비교
				* Equal ('=' or 'IN')
				* '>' 나 '<'
				* LIKE 으로 좌측 일치 패턴 (like 'OO%')
		* 위 두 조건을 모두 만족하는 경우
			* column_1 ~ column_i 까지는 범위 결정 조건
			* column_i ~ column_n 까지는 체크 조건
## 5.4 해시 (Hash) 인덱스
* 장점 : **동등 검색 비교**에 최적화 되어 있음
* 사용
	* 메모리 기반의 테이블에 주로 구현되어 있음
		* 디스크 기반에서는 거의 사용되지 않음
	* InnoDB의 버퍼풀에서 빠른 레코드 검색을 위한 Adaptive Hash Index 로 사용되기도 함
	* 오라클에서는 join 에 사용됨
### 5.4.1 구조 및 특성
* 장점
	* 실제 키 값과는 관계없이 인덱스 크기가 작고 검색이 빠름 (트리 구조가 아님)
		* 찾고자 하는 키값이 포함된 버킷을 해싱으로 바로 찾음
		* 버킷 = B-Tree의 노드
	* 해싱 결과가 key 값으로 들어가기 때문에 인덱스 크기가 작다
> (( 참고 ))
> * 검색을 위한 해시 알고리즘
> 	* 해시 함수의 결과가 넓어서 충돌이 적어야 함 = 검색 성능 높아짐
> * 테이블의 파티셔닝 용도
> 	* 해시가 필요한 파티션의 개수만큼 만들어내야 함
>	* = 해시 함수의 결과 범위를 좀게 사용
>	* ex) MySQL의 해시 파티션이 사용하는 방법
### 5.4.2 해시 인덱스의 가용성 및 효율성
* 해시 인덱스 단점
	* 키값 자체가 변환되므로 **범위 검색이나 원본 값 기준으로 정렬이 불가능**
#### 작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리
* 동등 조건으로 검색하는 쿼리들
`SELECT ... FROM tb_hash WHERE column = '검색어';`
`SELECT ... FROM tb_hash WHERE column <=> '검색어';`
`SELECT ... FROM tb_hash WHERE column IN ('검색어1', '검색어2');`
`SELECT ... FROM tb_hash WHERE column IS NULL;`
`SELECT ... FROM tb_hash WHERE column IS NOT NULL;`
	* <=> 기호는 NULL-Safe Equal
		* 비교 양쪽의 값이 NULL이 있을 때를 제외하고는 '=' 연산자와 똑같음
#### 해시 인덱스를 전혀 사용하지 못하는 쿼리
* 작업 범위 검색 뿐만 아니라 체크 조건 용도로도 못 씀
* *다중 컬럼*으로 생성된 해시 인덱스에서도 *모든 컬럼이 동등 조건으로 비교되는 경우에만 인덱스 사용 가능*
## 5.5 R-Tree 인덱스
* 공간 인덱스 (Spatial Index)
	* R-Tree 인덱스를 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
* B-Tree와 유사
* R-Tree의 인덱스는 2차원의 공간 개념값
* MySQL 공간 확장 기능
	* 공간 데이터를 저장할 수 있는 데이터 타입
	* 공간 데이터의 검색을 위한 공간 인덱스 (R-Tree 알고리즘)
	* 공간 데이터의 연산 함수 (거리 또는 포함 관계의 처리)
### 5.5.1 구조 및 특성
* MySQL 의 기하학적 도형 데이터 타입
	* point
	* line
	* polygon
	* geometry
		* point, line, polygon 모두 저장 가능
* MBR (Minimum Bounding Rectangle)
	* 해당 도형을 감싸는 최소 크기의 사각형
* **MBR 들의 포함관계를 B-Tree로 구현한 인덱스 = R-Tree**
* 최상위 MRB = Root Node 에 저장됨
* 차상위 MRB = 브렌치 노드에 저장됨
* 각 도형의 객체 = 리프 노드에 저장됨
### 5.5.2 R-Tree 인덱스의 용도
* 일반적으로 GPS 기준의 위도/경도 좌표 저장에 주로 사용됨
* 좌표 시스템에 기반을 둔 정보들 저장 (ex - CAD/CAM 또는 회로 디자인 등)
* **contains() 나 intersect() 같이 포함관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스 이용 가능**
## 5.6 Fractal-Tree 인덱스
### 5.6.1 Fractal-Tree의 특성
* B-Tree 문제점
	* 인덱스의 키를 변경하거나 검색하는 과정에서 랜덤 i/o 가 많이 발생하는 것
* Fractal-Tree
	* 랜덤이 아니라 순차 i/o로 변환해서 처리할 수 있도록 하는 것
	* 인덱스보다 더 많은 정렬 작업 필요
	* 인덱스의 단편화가 발생하지 않음
	* 인덱스 키값을 클러스터링함
		* B-Tree 보다 대용량 테이블에서 높은 성능을 보장
	* 급격한 성능저하 현상이 없음
* 에이징 (aging)
	* 오랜 시간동안 데이터가 변경되면서 단편화 발생으로 인해 인덱스의 효율이 떨어지는 현상
	* 그래서 따로 최적화 작업이 진행됨
	* Fractal 에서는 단편화가 발생하지 않으므로 최적화 작업 필요 없음
### 5.6.2 Fractal-Tree의 가용성과 효율성
* B-Tree의 장점을 그대로 가지고 있음
## 5.7 전문 검색 (Full Text Search) 인덱스
* 전문 검색 : **문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 것**
	* B-Tree 같은 경우에는 실제 칼럼의 값을 모두 인덱스 키로 사용하는 것이 아니라 1000byte (MyISAM) 또는 767byte (InnoDB) 까지만 잘라서 사용함
	* 따라서 전문 검색에는 적합한 인덱싱 방법이 아님
* 전문 검색 인덱스 종류 (문서의 키워드를 인덱싱 하는 방법에 따라 분류함)
	* 구분자 (Stopword)
	* N-그램
### 5.7.1 인덱스 알고리즘
* 키워드로 인덱스 구축
#### 구분자 (Stopword) 기법
* 정의 : **구분자를 이용해 키워드를 분석**하고 결과 단어를 인덱스로 생성해서 저장하고 검색에 이용하는 법
* 구분자 예시
	* 문장 기호
		* 공백
		* 탭 (띄워쓰기)
		* 마침표
	* 사용자가 정의한 문자열
* MySQL 의 내장 전문 검색 (FullText search) 엔진은 구분자 방식으로만 인덱싱 가능
* 내부적으로는 B-Tree 사용
	* 검색어나 본문 내용으로 정렬되어 조회되지 않음
	* 일치율 (Match Percent) 이 높은 순으로 출력됨
#### N-그램 (n-Gram) 기법
* 구분자 기법 단점
	* 각 국의 언어는 띄어쓰기가 없거나 문장 기호가 전혀 다른 경우가 많음
		* 다양한 언어에서 하나의 규칙을 적용해 키워드 추출하기 힘듦
	* 추출한 키워드의 뒷부분만으로 검색하는 건 불가능
* N-Gram
	* **본문의 무조건적으로 몇 글자씩 잘라서 인덱싱하는 방법**
	* 구분자보다 인덱싱 알고리즘이 복잡
	* 만들어진 인덱스도 상당히 큼
	* n = 인덱싱할 키워드의 최소 글자 (또는 바이트) 수
		* 일반적으로 2글자 단위 (2-Gram)
* 2-Gram
	* 인덱스 구성
		* 프론트엔드 인덱스
			* 최소 키워드에 대한 키 관리
		* 백엔드 인덱스
			* 2글자 이상의 키워드 묶음 (n-subsequence window)를 관리
	* 인덱스 생성 과정
		1. 본문을 2글자보다 큰 크기로 블록을 구분해서 백엔드 인덱스(3)를 생성
		2. 백엔드 인덱스의 키워드들을 2글자씩 잘라서 프론트엔드 인덱스(6) 생성
		3. 백엔드 인덱스와 프론트엔드 인덱스는 정규화 과정을 거쳐 B-Tree 알고리즘으로 인덱싱 됨
	* 인덱스 검색 방법 (순차적으로 진행)
		1. 입력된 검색어를 2바이트 단위로 동일하게 자름
		2. 프론트 엔드 인덱스 검색
		3. 2번 결과를 대상 후보군으로 선정
		4. 백엔드 인덱스를 통해 최종 검증
		5. 일치하는 결과 찾음
### 5.7.2 구분자와 N-그램의 차이
* 가장 큰 차이 : 검색 결과
* 인덱스 크기 : N-Gram > 구분자
* 인덱스 추가/삭제하는데 걸리는 시간 : N-Gram > 구분자
* 전문 검색 수행하는데 걸리는 시간 : N-Gram < 구분자
	* N-Gram의 트리톤이 구분자보다 2~3배 이상 빠름
	* 클라이언트의 동시 실행 쿼리 수가 많아질수록 차이가 더 벌어짐
* 검색어의 길이가 길어질수록 많은 성능 저하 발생
### 5.7.3 전문 검색 인덱스의 가용성
* 쿼리에 MATCH(...) 나 AGAINST(...) 구문으로 검색 쿼리를 작성해야 함
	* MATCH 절의 괄호에 포함되는 내용은 반드시 사용할 전문 검색 인덱스에 정의된 칼럼이 모두 명시되어야 함
## 5.8 비트맵 인덱스와 함수 기반 인덱스
* MySQL 에서 비트맵/함수 기반 인덱스를 지원하지 않음
* 우회해서 구현 가능
* ex) 길이가 긴 칼럼에 대한 동등 비교
	* 문자열의 해시값을 별도의 칼럼에 저장하고 해당 컬럼에 인덱스 생성하는 방식으로 사용
## 5.9 클러스터링 인덱스
* 비슷한 것들을 묶어서 저장
	* 비슷한 값들을 동시에 조회하는 경우가 많으므로
* InnoDB 에서 지원 (나머지 스토리지에서는 지원하지 않음)
### 5.9.1 클러스터링 인덱스
* 테이블의 **pk**에 대해서만 적용되는 내용
	* *pk 값이 비슷한 레코드끼리 묶어서 저장하는 것 = 클러스터링 인덱스*
	* 중요)) **pk 에 의해 레코드의 저장 위치가 결정됨**
		* = pk 값이 변경되면 물리적인 저장 위치도 변경되어야 함
* B-Tree와의 차이점
	* **클러스터링 인덱스는 인덱스의 리프 노드에 레코드의 모든 컬럼이 같이 저장되어 있음**
	* 즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리됨
* PK가 없는 InnoDB 테이블의 경우
	* 다음의 우선순위대로 PK 를 대체할 칼럼을 선택함
		1. PK 가 있으면 PK를 클러스터 키로 선택
		2. Not Null 옵션의 unique index 중 첫번째 인덱스를 클러스터 키로 선택
		3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가 후 클러스터 키로 선택
			* 자동 추가된 컬럼은 사용자들에게 노출되지 않음
			* 쿼리 문장에 명시적으로 사용 불가능
			* 즉, 아무런 의미 없는 값으로 클러스터링 되고 있음 = 별 도움 안됨
### 5.9.2 보조 인덱스 (Secondary Index) 에 미치는 영향
* PK가 SI 에 미치는 영향
	* MyISAM 이나 Memory db의 경우 pk나 si나 차이 없음
	* InnoDB는 보조키가 레코드 주소를 가지고 있는 경우를 방어하고자 **보조키는 항상 레코드가 아니라 PK를 저장하도록 구현**되어 있음
* ex) `SELECT * FROM employees WHERE first_name = 'Aamer';`
	* MyISAM
		* idx_first_name 인덱스 검색해서 레코드 주소 확인
		* 레코드 주소를 이용해 최종 레코드 가져옴
	* InnoDB
		* idx_first_name 인덱스를 검색해서 레코드의 pk 확인
		* pk를 이용해서 다시 한번 테이블을 검색한 후 최종 레코드 가져옴
		* InnoDB 가 MyISAM 보다 처리하는 과정이 많지만, pk로 레코드를 읽어오는 과정이 매우 빨라서 성능 걱정 필요 없음
### 5.9.3 클러스터 인덱스의 장점과 단점
#### 장점
* pk를 사용한 **검색이 빠름**
	* 특히 pk를 이용한 범위 검색의 경우
* 테이블의 모든 보조 인덱스가 pk를 가지고 있음 = *인덱스 만으로 처리되는 경우가 많음* (커버링 인덱스)
#### 단점
* 테이블의 모든 보조 인덱스가 클러스터 키(주로 pk)를 가지고 있음 = 클러스터 키값 크기가 클 수록 *전체적인 인덱스 크기가 커짐*
* 보조 인덱스를 통해 검색할 때 pk로 다시 한번 검색해야 하므로 **처리 성능이 조금 느림**
* INSERT 할 때 pk에 의해 레코드의 저장 위치가 결정됨 = 처리 성능이 느림
* pk를 변경할 때 레코드를 DELETE 하고 INSERT 하는 과정이 필요 = 처리 성능이 느림
### 5.9.4 클러스터 테이블 사용 시 주의사항
#### 클러스터 인덱스 키의 크기
* 클러스터 테이블의 경우 보조 인덱스가 pk(클러스터 키) 값을 포함하므로 pk 크기를 신중이 고려해 선택해야 함
	* ex) pk 크기가 10byte와 50byte 이고, 보조키가 5개인 경우
		* 10byte
			* 레코드 하나당 증가하는 인덱스 크기 : 10byte * 5 = 50 byte
			* 100만건의 레코드를 저장했을 때 증가하는 인덱스 크기 : 50byte * 1,000,000 = 47mb
		* 50byte
			* 레코드 하나당 증가하는 인덱스 크기 : 50byte * 5 = 250 byte
			* 100만건의 레코드를 저장했을 때 증가하는 인덱스 크기 : 250byte * 1,000,000 = 238mb
#### pk는 auto-increment 보다는 *가능한 경우* 업무적인 컬럼으로 생성할 것
* 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 pk로 설정하는 게 좋음
#### pk는 반드시 명시할 것
* 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExNDc4MjY5NzgsLTU4MDU0NzY0NSwyNT
I2NTcyMjMsMTk4MDQ3NDc3MCwxMzMyNzQ3NjIsMTg0ODUyMzgx
LDgxNTY4MDM4NCwtNDI3NjYyNDA5LC0xNTYzNTA3MTcsLTE5Nz
QwMjk0MzcsMTg4MzAxODA4MiwxMTg3MTY2OTk3LDEyNTUwOTU1
NzEsMTI5NDYxOTI2NSwtMTA1OTU2NjExM119
-->