# 12. 쿼리 종류별 lock
## 목차
* InnodDB의 기본 lock 방식
* SQL 문장별로 사용하는 lock
* InnoDB에서 deadlock 만들기

## 시작하기
* MySQL은 여러가지 스토리지 엔진을 사용할 수 있다.
* 각각의 스토리지 엔진이 모두 서로 각자의 잠금과 트랜잭션 기능을 지원하고 있다.
* 그래서 MySQL에서는 Lock과 관련된 문제를 다루기가 조금 까다롭다.

## 목적
* Lock에 대한 이해를 통해 Lock wait을 조금이라도 줄이고 빠른 속도로 처리되도록 쿼리를 개선하자.
* SQL 문장별로 어떤 잠금이 사용되는지, 어떻게 우회할 수 있는지 살펴보자.

# 12.1 InnoDB의 기본 잠금 방식
* InnoDB에서는 각 쿼리의 패턴별로 사용하는 lock이 다르다.
* 평소에 lock을 사용하지 않는 쿼리가 어떠한 기능이 추가되면서 lock을 사용하게 되는 등 복잡한 부분이 있어서 주의해야 한다.

## SELECT
* REPEATABLE-READ 이하 transaction isolation level에서는 Lock을 사용하지 않는다.
* 이미 lock 상태의 record를 읽는 것도 제약이 없다.
* SERIALIABLE isolation level에서는 모든 SELECT 쿼리에 LOCK IN SHARE MODE가 덧붙여진다. (read lock을 걸고 실행됨, 성능 저하 발생.)
### SELECT로 읽은 record에 lock을 거는 방법
* read-mode
	`SELECT * FROM employees WHERE emp_no =
* write-mode

## INSERT, UPDATE, DELETE

# 12.2 SQL 문장별로 사용하는 lock

## SELECT 쿼리의 lock
### SELECT ... FROM ...
### SELECT ... FROM ... LOCK IN SHARE MODE
### SELECT ... FROM ... FOR UPDATE

## INSERT 쿼리의 lock
### INSERT ...

### INSERT INTO ... ON DUPLICATE KEY UPDATE ...

### REPLACE ...


### INSERT INTO tb_new ... SELECT ... FROM tb_old ...

### REPLACE INTO tb_new ... SELECT ... FROM tb_old ...

## UPDATE 쿼리의 lock

### UPDATE ... WHERE ...

### UPDATE tb_test1 a, tb_test2 b ON ... SET a.column = b.column ...

## DELETE 쿼리의 lock

### DELETE FROM ... WHERE ...
### DELETE a FROM tb_test1 a, tb_test2 b ...

## DDL 문장의 lock
### CREATE TABLE tb_new ... SELECT ... FROM tb_old ...

### RENAME TABLE tb_test TO tb_Backup, tb_swap TO tb_test, ...


## InnoDB에서 여러 쿼리 패턴 간의 lock wait


# 12.3 InnoDB에서 deadlock 만들기

## 패턴1 (상호 거래 관련)

## 패턴2 (유니크 인덱스 관련)

## 패턴3 (외래키 관련)

## 패턴4 (서로 다른 인덱스를 통한 잠금)


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUxMzc4ODQwNCwxNzM0OTIyNDM1XX0=
-->