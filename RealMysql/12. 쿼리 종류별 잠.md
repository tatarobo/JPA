# 12. 쿼리 종류별 lock
## 목차
* InnodDB의 기본 lock 방식
* SQL 문장별로 사용하는 lock
* InnoDB에서 deadlock 만들기

## 시작하기
* MySQL은 여러가지 스토리지 엔진을 사용할 수 있다.
* 각각의 스토리지 엔진이 모두 서로 각자의 잠금과 트랜잭션 기능을 지원하고 있다.
* 그래서 MySQL에서는 Lock과 관련된 문제를 다루기가 조금 까다롭다.

## 목적
* Lock에 대한 이해를 통해 Lock wait을 조금이라도 줄이고 빠른 속도로 처리되도록 쿼리를 개선하자.
* SQL 문장별로 어떤 잠금이 사용되는지, 어떻게 우회할 수 있는지 살펴보자.

# 12.1 InnoDB의 기본 잠금 방식
* InnoDB에서는 각 쿼리의 패턴별로 사용하는 lock이 다르다.
* 평소에 lock을 사용하지 않는 쿼리가 어떠한 기능이 추가되면서 lock을 사용하게 되는 등 복잡한 부분이 있어서 주의해야 한다.

## SELECT
* REPEATABLE-READ 이하 transaction isolation level에서는 Lock을 사용하지 않는다.
* 이미 lock 상태의 record를 읽는 것도 제약이 없다.
* SERIALIABLE isolation level에서는 모든 SELECT 쿼리에 LOCK IN SHARE MODE가 덧붙여진다. (read lock을 걸고 실행됨, 성능 저하 발생.)

### SELECT로 읽은 record에 lock을 거는 방법
* read-mode
	```sql
	SELECT * FROM employees WHERE emp_no = 10001 LOCK IN SHARE MODE;
	```
* write-mode
	```sql
	SELECT * FROM employees WHERE emp_no = 10001 FOR UPDATE;
	```

- 위 두가지 방식 모두 다른 트랜잭션에서 변경하지 못하게 막는다.
- read-mode는 읽기에 대해서만 lock을 획득한 상태라서, 해당 레코드를 변경하려면 다시 write-lock을 획득해야 한다.
	- deadlock을 유발하는 가장 일반적인 형태.
	- 읽은 뒤 변경해야 한다면 처음부터 FOR UPDATE를 사용하자.
	- write-lock은 다른 트랜잭션에 대한 영향도가 크기 때문에, 반드시 읽고 나서 변경이 필요할 때만 사용하자.
- 위의 lock 방식들은 commit, rollback이 실행되면 잠금이 해제된다. 반드시 한 트랜잭션 내에서만 유효하다는 점을 기억하라.
- 아래와 같은 경우에는 사용할 수 없다.
	- 요청1에서 read or write lock을 사용하고 그냥 종료해버리면 해당 커넥션은 다시 사용할 수 없게 됨.
	- 요청2를 수행하지 않고 사용자가 떠나버리면, 요청1에서 잠긴 레코드는 영원히 잠금이 해제되지 않는다.
```mermaid
sequenceDiagram
사용자 ->> 웹서버 : 요청1
웹서버 ->> MySQL : SELECT ... FOR UPDATE
MySQL ->> 웹서버 : 
웹서버 ->> 사용자 : 응답1
사용자 ->> 웹서버 : 요청2
웹서버 ->> MySQL : UPDATE
웹서버 ->> MySQL : COMMIT
MySQL ->> 웹서버 : 
웹서버 ->> 사용자 : 응답2
```
* try finally로 반드시 commit, rollback이 수행되어 트랜잭션이 종료되도록 작성해야 한다.

## INSERT, UPDATE, DELETE

* 기본적으로 write-lock을 사용한다. 필요 시 read-lock을 사용할수도 있다.
* connection에 auto-commit이 활성화되어 있어도 SQL 처리 시 lock을 획득하고 해제하는 작업은 수행된다.
	* 각 SQL 문장마다 트랜잭션이 자동으로 시작되고 종료된다고 이해하자.
* auto-commit이 설정되지 않으면 SQL이 실행될 때 자동으로 트랜잭션이 시작되지만, 종료는 반드시 COMMIT, ROLLBACK 명령을 사용해서 수동으로 종료시켜야 한다.

### UPDATE, DELETE lock의 잠금
* 쿼리가 실행될 때 조건 절에 일치하는 레코드를 찾기 위해, 스캔하는 인덱스의 모든 레코드에 잠금을 건다.
	* where절 조건에 일치하지 않는 레코드도 lock 대상이 된다.
	* 조건 절에 조건을 모두 사용하지 않을 수 있다. (10개 조건을 지정했을 때 일부 조건만 사용)
	* MySQL은 인덱스를 적절히 사용할 수 있는 조건만 있으면 스토리지 엔진으로 전달한다.
	* InnoDB 스토리지 엔진은 WHERE절에 명시된 모든 조건에 일치하는 레코드만 선별적으로 lock을 거는 것이 불가능하다. 그래서 index를 사용할 수 있는 조건만 일치하면 모두 잠궈버린다.

```sql
-- index는 first_name만 존재한다.
UPDATE employees SET last_name = '...'
WHERE first_name='Gerogi' AND ' gender='F';
```
- 스토리지 엔진에서 `first_name='Gerogi'`인 모든 레코드를 lock 건다. (불필요하게!)
- MySQL 엔진에서 성별이 F인 사원의 last_name만 변경한다.
- UPDATE, DELETE 쿼리가 실행될 때는 항상 lock 대상이 변경 대상 레코드보다 범위가 크거나 같다.

### 정리
- select에서는 사용하지 않더라도 update, delete를 위해서 반드시 인덱스를 만들어야 할 때가 있다.
	- 제대로 된 인덱스를 사용하지 못하면, 쿼리가 상당히 비효율적으로 실행되며 동시성도 떨어진다.
- update, delete의 조건으로 사용되는 컬럼이 있다면 반드시 해당 컬럼에 인덱스를 생성하기를 권장한다.
	- 조건절 컬럼이 인덱스가 없으면, 대체할 인덱스가 없을 경우 모든 레코드에 lock을 걸고 변경 대상 레코드를 찾아서 변경한다. (MyISAM 보다도 동시성이 떨어질 수 있다)
- 바이너리 로그 기록 안할 경우,
	- REPETABLE-READ 가 아니라 READ-COMMITTED로 사용할 수 있다.
	- 이때는 인덱스와 관계없이 실제 변경되는 레코드만 lock을 걸게 된다.
		- 정확히는, 인덱스 조건에 일치하는 모든 레코드에 lock을 걸었다가, 실제 변경 대상을 모두 찾아서 조건이 일치하지 않는 대상은 lock을 해제한다.
		- SELECT의 read-lock, write-lock도 동일하다.

# 12.2 SQL 문장별로 사용하는 lock
* 쿼리 종류별로 사용하는 lock 방식이 다르다.
* 전혀 lock을 사용하지 않을 것으로 예상했던 쿼리도 lock을 사용하는 것이 있다.

## SELECT 쿼리의 lock
### SELECT ... FROM ...
### SELECT ... FROM ... LOCK IN SHARE MODE
### SELECT ... FROM ... FOR UPDATE

## INSERT 쿼리의 lock
### INSERT ...

### INSERT INTO ... ON DUPLICATE KEY UPDATE ...

### REPLACE ...


### INSERT INTO tb_new ... SELECT ... FROM tb_old ...

### REPLACE INTO tb_new ... SELECT ... FROM tb_old ...

## UPDATE 쿼리의 lock

### UPDATE ... WHERE ...

### UPDATE tb_test1 a, tb_test2 b ON ... SET a.column = b.column ...

## DELETE 쿼리의 lock

### DELETE FROM ... WHERE ...
### DELETE a FROM tb_test1 a, tb_test2 b ...

## DDL 문장의 lock
### CREATE TABLE tb_new ... SELECT ... FROM tb_old ...

### RENAME TABLE tb_test TO tb_Backup, tb_swap TO tb_test, ...


## InnoDB에서 여러 쿼리 패턴 간의 lock wait


# 12.3 InnoDB에서 deadlock 만들기

## 패턴1 (상호 거래 관련)

## 패턴2 (유니크 인덱스 관련)

## 패턴3 (외래키 관련)

## 패턴4 (서로 다른 인덱스를 통한 잠금)


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5NTY4NTIwNywxMzI3MzUxMTM3LDE3Mz
Q5MjI0MzVdfQ==
-->