# 4. Transaction과 Lock

## 4.1 트랜잭션

### 4.1.1 MySQL의 트랜잭션

### 4.1.2 주의사항

## 4.2 MySQL 엔진의 Lock

### 4.2.1 Global Lock

### 4.2.2 Table Lock

### 4.2.3 User Lock

### 4.2.4 Name Lock

## 4.3 MyISAM, Memory 스토리지 엔진의 Lock

### 4.3.1 Lock 획득

### 4.3.2 Lock 튜닝

### 4.3.3 테이블 수준의 Lock 확인 및 해제

## 4.4 InnoDB 스토리지 엔진의 Lock

##### Lock 정보 조회
* MySQL 5.0 이하 : `SHOW ENGINE INNODB STATUS`
* MySQL 5.1 이상 : 
	* INFORMATION_SCHEMA
		* INNODB_TRX : 트랜잭션 정보
		* INNODB_LOCKS : 해당 Lock을 어느 트랜잭션이 가지고 있는지 조회
		* INNODB_LOCK_WAITS : Lock 대기 조회

### 4.4.1 InnoDB Lock 방식
실제 쿼리 개발이나 튜닝에 큰 영향은 없다고 함.

* 낙관적 잠금(optimistic locking)
	* 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할 것이다(낙관적)라고 가정
	* 우선 변경 작업을 수행하고
	* 마지막에 lock contention이 있었는지 확인하고, 다르면 ROLLBACK 처리
* 비관적 잠금(pessimistic locking)
	* 변경하고자 하는 레코드에 대해서
	* 락을 먼저 획득하고
	* 그 다음에 변경 작업을 처리하는 방식
	* 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려짐.  InnoDB 기본 채택 방식

### 4.4.2 InnoDB Lock 종류
* InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공함.
* 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 태이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.

#### Record Lock
* 레코드 자체만을 잠그는 것
* InnoDB 스토리지 엔진에서는 레코드 자체가 아닌 인덱스의 레코드를 잠근다.
	* 인덱스가 없는 테이블도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금.
	* 인덱스에 거는것과 레코드에 거는 것은 상당히 크고 중요한 차이를 만든다.
		* `이후 설명`
* Primary Key, Unique index에 의한 변경 작업이 수행될 때 이 락을 사용함.

#### Gap Lock
* 레코드가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
* <u>레코드와 레코드 사이의 간격에 새로운 레코드가 생성(insert)되는 것을 제어하기 위함.
* 개념일 뿐 자체적으로 사용되지 않음. Next key Lock의 일부로 사용됨.

#### Next key Lock
* 레코드락와 갭락을 합쳐놓은 형태.
* 바이너리 로그를 Statement 포맷으로 사용하는 MySQL 서버에서는 REPETEABLE READ 격리 수준을 사용해야 함.
	* innodb_locks_unsafe_for_binlog 파라미터가 비활성화(0)되면 변경을 위해 검색하는 레코드에 nextkey lock이 걸린다.
	* 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터가 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적.
	* 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생함.
* 바이너리 로그 포맷을 ROW 형태로 바꾸는 것이 좋음.
	* 아직 널리 사용되지 않아서 안정성 확인이 어려움.
	* 로그파일의 크기가 상당히 커질 가능성이 많다.

#### Auto Increment Lock
* AUTO_INCREMENT 컬럼 속성
	* 동시에 여러 레코드가 insert 되는 경우, 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 제공
*  테이블 수준의 잠금 제공
	* insert, replace 쿼리에서만 필요함. update, delete는 사용하지 않음.
	* 값을 가져오는 순간에만 lock을 잡았다가 즉시 해제한다.
	* 명시적인 획득 방법은 없음.
	* 아주 짧은 시간만 락을 사용하기 때문에 대부분의 경우 문제되지 않음.
	*  MySQL 5.1 이상은 innodb_autoinc_lock_mode 값에 의해 작동방식을 변경할 수 있음.
##### innodb_autoinc_lock_mode = 0
* 모든 insert 문장에서 `Auto Increment Lock`을 사용한다.
##### innodb_autoinc_lock_mode = 1
* insert되는 레코드 건수를 정확히 예측 가능하다면, Latch를 사용한다.
	* Latch 설명 : https://tawool.tistory.com/237
	* 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가값을 가져오면 즉시 잠금이 해제됨.
* `insert ... select`와 같이 쿼리 실행 전에는 예측할 수 없을 경우에는 `Auto Increment Lock`을 사용한다.
	* 이 경우, insert 문장이 완료되기 전까지 자동 증가 락은 해제되지 않아서 다른 커넥션에서 insert를 실행하지 못하고 대기하게 된다.
* 대량 insert가 수행되면 한번에 여러 개의 자동 증가 값을 한번에 할당받아서 insert되는 레코드에 사용한다.
	* 자동 증가한 뒤에 트랜잭션이 실패할 경우에는 할당받았던 증가 값은 폐기된다. 즉, 연속되지 않고 누락된 값이 발생 가능하다.
* 이 설정 값에서는 최소한 하나의 insert 문장으로 추가되는 레코드는 연속된 값을 가지게 된다. `consecutive mode`

##### innodb_autoinc_lock_mode = 2
* 절대 `Auto Increment Lock`을 사용하지 않고 항상 Latch를 사용한다.
* 하나의 insert 문장으로 추가되는 레코드는 연속된 값을 가지는 것을 보장하지 않는다. `interleaved mode`
* `insert ... select` 문장에서도 다른 커넥션에서 insert를 수행할 수 있어서 동시 처리 성능이 높아진다.
* 유니크한 값이 생성된다는 것만 보장하며, 복제를 사용하는 경우 마스터와 슬레이브의 자동 증가 값이 달라질 가능성이 있어서 주의가 필요하다.

더 자세한 내용은 MySQL 매뉴얼의 “Configurable InnoDB Auto-Increment Locking"을 참조

### 4.4.3 인덱스와 Lock
* InnoDB의 레코드락은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식이다.
* 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.
	* 대체 가능한 인덱스가 여러개 존재한다면?
```sql
-- 레코드는 총 30만건이다.
-- index는 first_name만 존재한다.
> SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi';
253
> SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi' AND last_name = 'Klassen';
1
> UPDATE employees SET hire_date = NOW() WHERE first_name = 'Georgi' AND last_name = 'Klassen';
```
* 1건의 업데이트 실행.
	* index는 first_name 뿐이므로, 253건의 레코드가 모두 잠긴다.
	* UPDATE 문장을 위해 적절히 인덱스가 준비돼있지 않다면 동시성이 상당히 떨어진다.
* 만약 인덱스가 하나도 없다면?
	* 테이블을 풀 스캔하면서 UPDATE 작업이 처리됨.
	* 30만건의 레코드를 모두 잠근다.
	* 인덱스 설계가 매우 중요한 이유.

### 4.4.4 트랜잭션 격리 수준과 Lock
* 불필요한 레코드 잠금 현상은 InnoDB의 `Next key Lock` 때문에 발생한다.
* 이게 필요한 주 원인은 복제를 위한 바이너리 로그 때문이다.
	* ROW Based Binary Log를 사용하거나, 바이너리 로그를 사용하지 않는다면 이 락의 사용을 대폭 줄일 수 있다.
	* 아래 설정 조합으로 `Next key Lock` 을 없앨 수 있으나, Unique Key, 외래키에 대한 Gap Lock은 없어지지 않는다.

	| 설정 조합 |
	|--|
	| - READ-COMMITTED 수준으로 설정한다.<br>- 바이너리 로그 비활성화 |
	| - READ-COMMITTED 수준으로 설정한다.<br>- 레코드 기반 바이너리 로그 사용<br> - innodb_locks_unsafe_for_binlog=1 |

* 설정 후 UPDATE 문장 처리 시 일치하는 레코드를 인덱스를 이용해 검색 할 때,
	* 우선 인덱스만 비교해서 일치하는 레코드에 대해 배타적 잠금 수행,
	* 그 후 나머지 조건을 비교해서 일치하지 않는 레코드는 즉시 잠금을 해제함.

### 4.4.5 레코드 수준의 Lock 확인 및 해제
* InnoDB 스토리지 엔진의 테이블 레코드 수준 잠금
	* 더 복잡, 오랜시간 잠겨진 상태로 남아있어도 잘 발견되지 않음.
* 테이블 수준 잠금
	* 단순, 문제의 원인이 쉽게 발견되고 해결될 수 있음.
#### MySQL 5.0 이하 잠금 확인 및 해제
```
1 : BEGIN
1 : UPDATE employees SET birth_date = NOW() WHERE emp_no = 100001;
2 : UPDATE employees SET hire_date = NOW() WHERE emp_no = 100001;
3 : UPDATE employees SET birth_date = NOW(), hire_date = NOW() WHERE emp_no = 100001;
```
* 1번이 업데이트 하면서 락 획득, 2/3번은 락 대기 상태.
* `SHOW PROCESSLIST`
	* 락 대기중인 프로세스의 State는 Updating으로 표시됨.
	* 느낌 상으로 Updating인데 2~3초 실행 중이라면 아.. 락 대기중이구나 라고 알 수 있음.
		* Primary key나 Index를 이용하는 경우에 한정.
		* full scan 쿼리는 락 대기가 아니더라도 그 이상의 시간이 소요될 수 있음.
* `SHOW ENGINE INNODB STATUS`
	* `TRANSACTIONS` 섹션
	* 레코드를 오랫동안 잠그고 있는 프로세스가 있는지 여부를 확인
		* 트랜잭션이 오랜 시간동안 실행되고 있는 줄을 찾는다.
		* 상태가 ACTIVE, 그 뒤의 시간이 큰 값을 가지는 트랜잭션을 찾는다.
	*  <u>쿼리에 필요한 Lock이 무엇인지 예측해야 한다. -> 실행계획

#### MySQL 5.1 이상 잠금 확인 및 해제
* information_schema.innodb_locks : 어떤 잠금이 존재하는지 관리
* information_schema.innodb_trx : 어떤 트랜잭션이 어떤 잠금을 기다리고 있는지 관리
* information schema.innodb_lock_waits : 잠금에 의한 프로세스 간의 의존 관계를 관리
```sql
> SELECT * FROM information_schema.innodb_locks;
lock_id(34A7:78:298:25), lock_trx_id(34A7),
lock_mode(X), lock_type(RECORD), lock_table(tablename), lock_index('PRIMARY'),
lock_space(78), lock_page(298), lock_rec(25), lock_data(100001)
...

> SELECT * FROM information_schema.innodb_trx;
trx_id(34A7), trx_state(LOCK_WAIT), trx_started(time..), trx_query(UPDATE ...)
```

* 어떤 커넥션이 어떤 커넥션을 기다리게 만드는지 확인
```sql
SELECT r.trx_id waiting_trx_id
       r.trx_mysql_thread_id waiting_thread,
       r.trx_query waiting_query,
       b.trx_id blocking_trx_id,
       b.trx_mysql_thread_id blocking_thread,
       b.
```

## 4.5 MySQL의 격리 수준

### 4.5.1 READ UNCOMMITTED

### 4.5.2 READ COMMITTED

### 4.5.3 REPEATABLE READ

### 4.5.4 SERIALIZABLE

### 4.5.5 REPEATABLE READ & READ COMMITTED 성능 비교


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIzODczMzI1NSwxMDY2ODk1NDI2LC0yMT
QxNDE3MTI2LC0zMzI2NjE1MTAsLTYxNjIxMTk5LDQ0OTE5Mzc2
OSwyMDkwNjM0NzE1LDIwNTgyNDI1NjcsLTEwMzQyMDU1NDQsMT
U4MjQxOTIzMF19
-->