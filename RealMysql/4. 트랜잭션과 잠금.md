# 4. Transaction과 Lock

## 4.1 트랜잭션

### 4.1.1 MySQL의 트랜잭션

### 4.1.2 주의사항

## 4.2 MySQL 엔진의 Lock

### 4.2.1 Global Lock

### 4.2.2 Table Lock

### 4.2.3 User Lock

### 4.2.4 Name Lock

## 4.3 MyISAM, Memory 스토리지 엔진의 Lock

### 4.3.1 Lock 획득

### 4.3.2 Lock 튜닝

### 4.3.3 테이블 수준의 Lock 확인 및 해제

## 4.4 InnoDB 스토리지 엔진의 Lock

##### Lock 정보 조회
* MySQL 5.0 이하 : `SHOW ENGINE INNODB STATUS`
* MySQL 5.1 이상 : 
	* INFORMATION_SCHEMA
		* INNODB_TRX : 트랜잭션 정보
		* INNODB_LOCKS : 해당 Lock을 어느 트랜잭션이 가지고 있는지 조회
		* INNODB_LOCK_WAITS : Lock 대기 조회

### 4.4.1 InnoDB Lock 방식
실제 쿼리 개발이나 튜닝에 큰 영향은 없다고 함.

* 낙관적 잠금(optimistic locking)
	* 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할 것이다(낙관적)라고 가정
	* 우선 변경 작업을 수행하고
	* 마지막에 lock contention이 있었는지 확인하고, 다르면 ROLLBACK 처리
* 비관적 잠금(pessimistic locking)
	* 변경하고자 하는 레코드에 대해서
	* 락을 먼저 획득하고
	* 그 다음에 변경 작업을 처리하는 방식
	* 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려짐.  InnoDB 기본 채택 방식

### 4.4.2 InnoDB Lock 종류
* InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공함.
* 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 태이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.

#### Record Lock
* 레코드 자체만을 잠그는 것
* InnoDB 스토리지 엔진에서는 레코드 자체가 아닌 인덱스의 레코드를 잠근다.
	* 인덱스가 없는 테이블도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금.
	* 인덱스에 거는것과 레코드에 거는 것은 상당히 크고 중요한 차이를 만든다.
		* `이후 설명`
* Primary Key, Unique index에 의한 변경 작업이 수행될 때 이 락을 사용함.

#### Gap Lock
* 레코드가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
* 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(insert)되는 것을 제어하기 위함.
* 개념일 뿐 자체적으로 사용되지 않음. Next key Lock의 일부로 사용됨.
* 
#### Next key Lock

#### Auto Increment Lock

### 4.4.3 인덱스와 Lock

### 4.4.4 트랜잭션 격리 수준과 Lock

### 4.4.5 레코드 수준의 Lock 확인 및 해제

## 4.5 MySQL의 격리 수준

### 4.5.1 READ UNCOMMITTED

### 4.5.2 READ COMMITTED

### 4.5.3 REPEATABLE READ

### 4.5.4 SERIALIZABLE

### 4.5.5 REPEATABLE READ & READ COMMITTED 성능 비교


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE2NTI3NDc3MCwxNTgyNDE5MjMwXX0=
-->