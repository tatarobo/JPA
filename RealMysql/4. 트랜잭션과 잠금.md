# 4. Transaction과 Lock

## 4.1 트랜잭션

### 4.1.1 MySQL의 트랜잭션

### 4.1.2 주의사항

## 4.2 MySQL 엔진의 Lock

### 4.2.1 Global Lock

### 4.2.2 Table Lock

### 4.2.3 User Lock

### 4.2.4 Name Lock

## 4.3 MyISAM, Memory 스토리지 엔진의 Lock

### 4.3.1 Lock 획득

### 4.3.2 Lock 튜닝

### 4.3.3 테이블 수준의 Lock 확인 및 해제

## 4.4 InnoDB 스토리지 엔진의 Lock

##### Lock 정보 조회
* MySQL 5.0 이하 : `SHOW ENGINE INNODB STATUS`
* MySQL 5.1 이상 : 
	* INFORMATION_SCHEMA
		* INNODB_TRX : 트랜잭션 정보
		* INNODB_LOCKS : 해당 Lock을 어느 트랜잭션이 가지고 있는지 조회
		* INNODB_LOCK_WAITS : Lock 대기 조회

### 4.4.1 InnoDB Lock 방식
실제 쿼리 개발이나 튜닝에 큰 영향은 없다고 함.

* 낙관적 잠금(optimistic locking)
	* 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할 것이다(낙관적)라고 가정
	* 우선 변경 작업을 수행하고
	* 마지막에 lock contention이 있었는지 확인하고, 다르면 ROLLBACK 처리
* 비관적 잠금(pessimistic locking)
	* 변경하고자 하는 레코드에 대해서
	* 락을 먼저 획득하고
	* 그 다음에 변경 작업을 처리하는 방식
	* 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려짐.  InnoDB 기본 채택 방식

### 4.4.2 InnoDB Lock 종류
* InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공함.
* 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 태이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.

#### Record Lock
* 레코드 자체만을 잠그는 것
* InnoDB 스토리지 엔진에서는 레코드 자체가 아닌 인덱스의 레코드를 잠근다.
	* 인덱스가 없는 테이블도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금.
	* 인덱스에 거는것과 레코드에 거는 것은 상당히 크고 중요한 차이를 만든다.
		* `이후 설명`
* Primary Key, Unique index에 의한 변경 작업이 수행될 때 이 락을 사용함.

#### Gap Lock
* 레코드가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
* <u>레코드와 레코드 사이의 간격에 새로운 레코드가 생성(insert)되는 것을 제어하기 위함.
* 개념일 뿐 자체적으로 사용되지 않음. Next key Lock의 일부로 사용됨.

#### Next key Lock
* 레코드락와 갭락을 합쳐놓은 형태.
* 바이너리 로그를 Statement 포맷으로 사용하는 MySQL 서버에서는 REPETEABLE READ 격리 수준을 사용해야 함.
	* innodb_locks_unsafe_for_binlog 파라미터가 비활성화(0)되면 변경을 위해 검색하는 레코드에 nextkey lock이 걸린다.
	* 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터가 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적.
	* 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생함.
* 바이너리 로그 포맷을 ROW 형태로 바꾸는 것이 좋음.
	* 아직 널리 사용되지 않아서 안정성 확인이 어려움.
	* 로그파일의 크기가 상당히 커질 가능성이 많다.

#### Auto Increment Lock
* AUTO_INCREMENT 컬럼 속성
	* 동시에 여러 레코드가 insert 되는 경우, 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 제공
*  테이블 수준의 잠금 제공
	* insert, replace 쿼리에서만 필요함. update, delete는 사용하지 않음.
	* 값을 가져오는 순간에만 lock을 잡았다가 즉시 해제한다.
	* 명시적인 획득 방법은 없음.
	* 아주 짧은 시간만 락을 사용하기 때문에 대부분의 경우 문제되지 않음.
	*  MySQL 5.1 이상은 innodb_autoinc_lock_mode 값에 의해 작동방식을 변경할 수 있음.
##### innodb_autoinc_lock_mode = 0
* 모든 insert 문장에서 `Auto Increment Lock`을 사용한다.
##### innodb_autoinc_lock_mode = 1
* insert되는 레코드 건수를 정확히 예측 가능하다면, Latch를 사용한다.
	* Latch 설명 : https://tawool.tistory.com/237
	* 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가값을 가져오면 즉시 잠금이 해제됨.
* insert ... select와 같이 쿼리 실행 전에는 예측할 수 없을 경우에는 `Auto Increment Lock`을 사용한다.
	* insert 문장이 완료되기 전까지 자동 증가 락은 해제되지 않아서 다른 커넥션에서 insert를 실행하지 못하고 대기하게 된다.
		* 응?? 위에서는 값을 가져오고 바로 해제된다며..
* 대량 insert가 수행되면 한번에 여러 개의 자동 증가 값을 한번에 할당받아서 insert되는 레코드에 사용한다.
	* 자동 증가한 뒤에 트랜잭션이 실패할 경우에는 할당받았던 증가 값은 폐기된다. 즉, 연속되지 않고 누락된 값이 발생 가능하다.
* 이 설정 값에서는 최소한 하나의 insert 문장으로 추가되는 레코드는 연속된 값을 가지게 된다. con

##### innodb_autoinc_lock_mode = 2
* 절대 `Auto Increment Lock`을 사용하지 않고 항상 Latch를 사용한다.
* 하나의 insert 문장으로 추가되는 레코드는 연속된 값을 가지는 것을 보장하지 않는다. interleaved mode


### 4.4.3 인덱스와 Lock

### 4.4.4 트랜잭션 격리 수준과 Lock

### 4.4.5 레코드 수준의 Lock 확인 및 해제

## 4.5 MySQL의 격리 수준

### 4.5.1 READ UNCOMMITTED

### 4.5.2 READ COMMITTED

### 4.5.3 REPEATABLE READ

### 4.5.4 SERIALIZABLE

### 4.5.5 REPEATABLE READ & READ COMMITTED 성능 비교


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI5NjUwMjIwOCwyMDkwNjM0NzE1LDIwNT
gyNDI1NjcsLTEwMzQyMDU1NDQsMTU4MjQxOTIzMF19
-->